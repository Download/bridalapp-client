{"version":3,"file":"bridalapp.min.js","sources":["lang/class.js","bridalapp/persistent.js","bridalapp/named.js","bridalapp/account.js","bridalapp/brand.js","bridalapp/log.js","bridalapp/datastore.js","bridalapp/synchabledatastore.js","bridalapp/synchrequest.js","bridalapp/synchresponse.js","bridalapp/syncheddatastore.js","bridalapp/rhaboodatastore.js","bridalapp/restdatastore.js","bridalapp/brands.js","bridalapp/category.js","bridalapp/credential.js","bridalapp/group.js","bridalapp/password-credential.js","bridalapp/product.js","bridalapp/products.js","bridalapp/rating.js","bridalapp/ratings.js","bridalapp/role.js","bridalapp.js"],"names":["define","Class","name","parent","args","arrayify","arguments","String","shift","classname","eval","klass","superclass","subclasses","subclass","prototype","push","i","len","length","addMethods","initialize","constructor","argumentNames","fn","names","toString","match","split","replace","it","Object","toArray","results","Array","bind","func","undefined","obj","splice","apply","concat","wrap","wrapper","this","src","keys","key","ancestor","props","val","argNames","method","m","valueOf","sub","subsub","Suid","Persistent","id","type","version","equals","other","value","revive","t","fromJSON","json","JSON","parse","persistent","arg","item","j","one","comparator","indexOf","list","element","matches","items","criteria","call","hasOwnProperty","isArray","pluck","attr","clone","stringify","page","pageSize","pageIndex","start","end","slice","Math","max","min","eachArg","Named","$super","Account","roles","groups","credentials","Brand","log","out","METHODS","console","error","con","nul","level","lvl","logLevel","DEBUG","INFO","WARN","ERROR","NONE","DataStore","url","cfg","listeners","throttle","on","event","listener","trigger","me","triggered","Date","now","timeout","clearTimeout","setTimeout","off","load","Promise","resolve","count","save","delete","typeFactories","registerType","factory","fromType","fromUrl","idx","s","substring","SynchableDataStore","get","looksSynched","lastSynched","getTime","createdItems","updatedItems","deletedItems","synch","isSynching","newDate","staleItems","failedItems","futureItems","set","del","SynchRequest","unsynchedDuration","synchDuration","currentIds","currentVersions","SynchResponse","deletedIds","$","handleLoadedItems","old","changed","staleIdx","handleSavedItems","future","merged","handleDeletedItems","poorMansSynch","synching","reject","pollInterval","remoteDataStore","then","dirty","deleted","e","synchError","autoSynch","autoSynchActive","setInterval","synchInterval","SynchedDataStore","remoteSynch","localDataStore","urls","localParts","localType","localRepo","join","localStore","remoteParts","remoteType","remoteRepo","remoteStore","supportsSynch","req","filter","response","RhabooDataStore","rhaboo","store","repoIdx","storeIdx","lastIndexOf","repo","backup","db","updated","removed","date","write","stale","failed","Rhaboo","RestDataStoreFactory","RestDataStore","retryCount","retryWaitTime","remoteRequest","all","synchRequest","data","retries","info","parts","request","errorHandler","pre","ajax","contentType","processData","done","statusText","jqXHR","responseText","fail","textStatus","errorThrown","warn","status","retry","err","Error","after","retryAfter","getResponseHeader","tmp","parseInt","isNaN","errorhandler","hashIdx","hash","qsIdx","qs","encodeURIComponent","Brands","Category","Credential","Group","description","PasswordCredential","password","Product","priceWholesaleEuroCent","priceConsumerEuroCent","brandId","brandName","categoryId","categoryName","tags","Products","Rating","productId","accountId","score","Ratings","Role","globalize","global"],"mappings":"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","sourcesContent":["define('lang/class',[], function(){\r\n\t/**\r\n\t * Class([name] [, parent], object [, object] [, object])\r\n\t *\r\n\t * Creates a new class with the given name, parent and methods.\r\n\t *\r\n\t * name    String, Optional. The name of the new class. \r\n\t *         If not specified the new class will be anonymous.\r\n\t * parent  Class object, optional. The parent class for the new class.\r\n\t * object  Object, Required. One or more objects containing the methods \r\n\t *         and fields to add to the new class.\r\n\t */\r\n\tfunction Class() {\r\n\t\tvar name = '', parent = null, args = arrayify(arguments);\r\n\t\tif (typeof args[0] === 'string' || args[0] instanceof String) {\r\n\t\t\tname = args.shift();\r\n\t\t}\r\n\t\tif (typeof args[0] === 'function') {\r\n\t\t\tparent = args.shift();\r\n\t\t}\r\n\t\tvar classname = name || 'klass';\r\n\t\teval('var klass = function ' + classname + '() {this.initialize.apply(this, arguments);}'); // jshint ignore:line\r\n\t\tklass.classname = classname;\r\n\t\tklass.superclass = parent;\r\n\t\tklass.subclasses = [];\r\n\r\n\t\tif (parent) {\r\n\t\t\tvar subclass = function() { };\r\n\t\t\tsubclass.prototype = parent.prototype;\r\n\t\t\tklass.prototype = new subclass();\r\n\t\t\tparent.subclasses.push(klass);\r\n\t\t}\r\n\r\n\t\tfor (var i=0, len=args.length; i<len; i++) {\r\n\t\t\taddMethods(klass, args[i]);\r\n\t\t}\r\n\t\tif (!klass.prototype.initialize) {\r\n\t\t\tklass.prototype.initialize = function() { };\r\n\t\t}\r\n\t\tklass.prototype.constructor = klass;\r\n\t\treturn klass;\r\n\t}\r\n\r\n\tClass.subclass = function Class_subclass(klass, name) {\r\n\t\tif (!klass) {return;}\r\n\t\tif (klass.classname === name) {return klass;}\r\n\t\tfor (var i=0, sub; sub=klass.subclasses[i]; i++) {\r\n\t\t\tif (sub.classname === name) {return sub;}\r\n\t\t\tvar subsub = Class.subclass(sub, name);\r\n\t\t\tif (subsub) {return subsub;}\r\n\t\t}\r\n\t};\r\n\r\n\tfunction argumentNames(fn) {\r\n\t\tvar i, len, names = fn.toString().match(/^[\\s\\(]*function[^(]*\\((.*?)\\)/)[1].split(',');\r\n\t\tfor (i=0, len=names.length; i<len; i++) {\r\n\t\t\tnames[i] = names[i].replace(/^\\s+/, '').replace(/\\s+$/, '');\r\n\t\t}\r\n\t\treturn len === 1 && !names[0] ? [] : names;\r\n\t}\r\n\r\n\tfunction arrayify(it) {\r\n\t\tif (!it) {return [];}\r\n\t\tif ('toArray' in Object(it)) {return it.toArray();}\r\n\t\tvar len = it.length || 0, results = new Array(len);\r\n\t\twhile (len--) {results[len] = it[len];}\r\n\t\treturn results;\r\n\t}\r\n\r\n\tfunction bind(func) {\r\n\t\tif (arguments.length < 3 && arguments[1] === undefined) {return func;}\r\n\t\tvar args = arrayify(arguments), obj = args.splice(0, 2)[1];\r\n\t\treturn function() {\r\n\t\t\treturn func.apply(obj, args.concat(arrayify(arguments)));\r\n\t\t};\r\n\t}\r\n\r\n\tfunction wrap(func, wrapper) {\r\n\t\treturn function() {\r\n\t\t\treturn wrapper.apply(this, [bind(func, this)].concat(arrayify(arguments)));\r\n\t\t};\r\n\t}\r\n\r\n\tfunction addMethods(klass, src) {\r\n\t\tfunction keys(obj) {\r\n\t\t\tvar results = [];\r\n\t\t\tfor (var key in obj) {\r\n\t\t\t\tresults.push(key);\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t}\r\n\r\n\t\tvar ancestor = klass.superclass && klass.superclass.prototype, props = keys(src);\r\n\r\n\t\tfor (var i=0, key; key=props[i]; i++) {\r\n\t\t\tvar val = src[key];\r\n\t\t\tif (ancestor && (typeof val === 'function')) {\r\n\t\t\t\tvar argNames = argumentNames(val);\r\n\t\t\t\tif ((argNames.length > 0) && (argNames[0] === '$super')) {\r\n\t\t\t\t\tvar method = val;\r\n\t\t\t\t\tval = wrap((function(m) {\r\n\t\t\t\t\t\treturn function() {\r\n\t\t\t\t\t\t\treturn ancestor[m].apply(this, arguments); \r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t})(key), method); // jshint ignore:line\r\n\t\t\t\t\tval.valueOf = bind(method.valueOf, method);\r\n\t\t\t\t\tval.toString = bind(method.toString, method);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tklass.prototype[key] = val;\r\n\t\t}\r\n\t}\r\n\r\n\treturn Class;\r\n});\r\n\n","define('bridalapp/persistent',['lang/class', 'suid'], function (Class, Suid) {\r\n\tvar Persistent = Class('Persistent', {\r\n\t\tinitialize: function Persistent_initialize(obj) {\r\n\t\t\tthis.id = (obj && obj.id) || Suid(0);\r\n\t\t\tthis.type = this.constructor.classname;\r\n\t\t\tthis.version = obj && (obj.version !== undefined) ? obj.version : null;\r\n\t\t},\r\n\t\t\r\n\t\tequals: function Persistent_equals(other){\r\n\t\t\treturn other && (\r\n\t\t\t\t\t(other instanceof Persistent && other.id.value === this.id.value) ||\r\n\t\t\t\t\t(other instanceof Suid && other.value === this.id.value) || \r\n\t\t\t\t\t(other == this.id.value) \r\n\t\t\t) ;\r\n\t\t},\r\n\t\t\r\n\t\ttoString: function Persistent_toString() {\r\n\t\t\treturn '[Object ' + this.type + ' ' + this.id.toString() + ' v' + this.version + ']';\r\n\t\t}\r\n\t});\r\n\t\r\n\tPersistent.revive = function Persistent_revive(key, value) {\r\n\t\tvar t = value && typeof value === 'object' && typeof value.type === 'string' && value.type,\r\n\t\t\tconstructor = Class.subclass(Persistent, t);\r\n\t\treturn constructor ? new constructor(value) : Suid.revive(key, value);\r\n\t}; \r\n\t\r\n\tPersistent.fromJSON = function Persistent_fromJSON(json) {\r\n\t\treturn JSON.parse(json, Persistent.revive);\r\n\t};\r\n\t\r\n\tPersistent.persistent = function Persistent_persistent(arg) {\r\n\t\tif (arguments.length === 1) {return arg instanceof Persistent && arg.version !== null;}\r\n\t\tvar results = [];\r\n\t\tfor (var i=0; arg=arguments[i]; i++) {\r\n\t\t\tif (Persistent.persistent(arg)) {results.push(arg);}\r\n\t\t\telse if ('length' in arg){\r\n\t\t\t\tfor (var j=0, item; item=arg[j]; j++) {\r\n\t\t\t\t\tif (Persistent.persistent(item)) {results.push(item);}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.equals = function Persistent_static_equals(one, other, comparator) {\r\n\t\treturn (one == other ||\r\n\t\t\t\t(comparator && comparator(one, other) === 0) ||\r\n\t\t\t\tone && one.equals && one.equals(other) ||\r\n\t\t\t\tother && other.equals && other.equals(one) ||\r\n\t\t\t\t(typeof one === 'object' && one && one.valueOf() == other) ||\r\n\t\t\t\t(typeof other === 'object' && other && other.valueOf() == one));\r\n\t};\r\n\t\r\n\t// returns index of given element in given list, using given comparator\r\n\tPersistent.indexOf = function Persistent_indexOf(list, element, comparator) {\r\n\t\tfor (var i=0, item; item=list[i]; i++) {\r\n\t\t\tif (Persistent.equals(item, element)) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t};\r\n\r\n\t// CRITERIA on the cheap\r\n\tPersistent.matches = function Persistent_matches(items, criteria) {\r\n\t\tvar results = Array.prototype.concat.call(items || []);\r\n\t\tif (criteria) {\r\n\t\t\tfor (var i=results.length-1; i>=0; i--) {\r\n\t\t\t\tfor (var key in criteria) {\r\n\t\t\t\t\tif (criteria.hasOwnProperty(key)) {\r\n\t\t\t\t\t\tif ((((Array.isArray && Array.isArray(criteria[key])) || (criteria[key] instanceof Array)) && (Persistent.indexOf(criteria[key], items[i][key]) === -1)) \r\n\t\t\t\t\t\t\t\t|| (! Persistent.equals(items[i][key], criteria[key]))) {\r\n\t\t\t\t\t\t\tresults.splice(i,1); \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.pluck = function Persistent_pluck(items, attr) {\r\n\t\tvar results = [];\r\n\t\tfor (var i=0,item; item=items[i]; i++) {\r\n\t\t\tif (item[attr] !== undefined) {\r\n\t\t\t\tresults.push(item[attr]); \r\n\t\t\t}\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.clone = function Persistent_clone(items) {\r\n\t\tvar results = [];\r\n\t\tif (arguments.length > 1) {return Persistent.clone(arguments);}\r\n\t\tif (! ('length' in items)) {return items instanceof Persistent && items.clone ? items.clone() : Persistent.fromJSON(JSON.stringify(items));}\r\n\t\tvar results = [];\r\n\t\tfor (var i=0, item; item=items[i]; i++) {\r\n\t\t\tresults.push(Persistent.clone(item));\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.page = function Persistent_page(results, pageSize, pageIndex) {\r\n\t\tif (pageSize) {\r\n\t\t\tvar start = (pageIndex || 0) * pageSize,\r\n\t\t\t\tend = pageIndex * (pageSize+1);\r\n\t\t\tif ((end < 0) || (end <= start) || (start > results.length)) {return [];}\r\n\t\t\treturn results.slice(Math.max(start,0), Math.min(end, results.length));\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.eachArg = function Persistent_eachArg(args, obj, fn) {\r\n\t\tif (('length' in args) && (! (args instanceof Persistent))) {\r\n\t\t\tvar results = [];\r\n\t\t\tfor (var i=0,item; item=args[i]; i++) {\r\n\t\t\t\tresults.push.apply(results, Persistent.eachArg(item, obj, fn));\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t}\r\n\t\treturn fn.call(obj, args);\r\n\t}\r\n\t\r\n\treturn Persistent;\r\n});\r\n\n","define('bridalapp/named',['lang/class', 'bridalapp/persistent'], function (Class, Persistent) {\r\n\tvar Named = Class('Named', Persistent, {\r\n\t\tinitialize: function Named_initialize($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.name = (obj && obj.name) || null;\r\n\t\t},\r\n\t\t\r\n\t\ttoString: function Named_toString() {\r\n\t\t\treturn '[Object ' + this.type + ' \\'' + this.name + '\\' ' + this.id.toString() + ' v' + this.version + ']';\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn Named;\r\n});\r\n\n","define('bridalapp/account',['lang/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Account = Class('Account', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.roles = (obj && obj.roles) || [];\r\n\t\t\tthis.groups = (obj && obj.groups) || [];\r\n\t\t\tthis.credentials = (obj && obj.credentials) || [];\r\n\t\t}\r\n\t});\r\n\r\n\treturn Account;\r\n});\n","define('bridalapp/brand',['lang/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Brand = Class('Brand', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t}\r\n\t});\r\n\r\n\treturn Brand;\r\n});\n","define('bridalapp/log',[], function () {\r\n\tvar METHODS = ['log','info','warn','error'],\r\n\t\tout = ('console' in this) && console.error ? console : {},\r\n\t\tcon = {}, // save backups of native console functions here\r\n\t\tnul = {}, // keep empty console functions here\r\n\t\ti, key;\r\n\r\n\tfor (i=0; key=METHODS[i]; i++) {\r\n\t\tnul[key] = function(){}\r\n\t\tcon[key] = out[key] || nul[key];\r\n\t}\r\n\r\n\tfunction log() {\r\n\t\treturn out;\r\n\t}\r\n\r\n\tlog.level = function log_level(lvl) {\r\n\t\tif ((lvl !== undefined) && (lvl >= 0) && (lvl <= 4) && (lvl !== logLevel)) {\r\n\t\t\tlogLevel = lvl;\r\n\t\t\t// modify the console methods: \r\n\t\t\t// those which are below the current log level get replaced by empty functions\r\n\t\t\tfor (var i=0,fn; fn=METHODS[i]; i++) {\r\n\t\t\t\tout[fn] = i >= lvl ? con[fn] : nul[fn];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn logLevel;\r\n\t};\r\n\r\n\tlog.level.DEBUG = 0;\r\n\tlog.level.INFO = 1;\r\n\tlog.level.WARN = 2;\r\n\tlog.level.ERROR = 3;\r\n\tlog.level.NONE = 4;\r\n\t\r\n\tvar logLevel = log.level.DEBUG;\r\n\r\n\treturn log;\r\n});\r\n\n","define('bridalapp/datastore',['lang/class'], function (Class) {\r\n\t'use strict';\r\n\t\r\n\t/**\r\n\t * 'Abstract' base class for datastores.\r\n\t * \r\n\t * <p>Interaction with the datastore happens through four methods:</p>\r\n\t * <dl>\r\n\t *   <dt><code>Promise <b>load</b>(criteria, pageSize, pageIndex)</code></dt>\r\n\t *   <dd>Loads items from the store that match the given <code>criteria</code> (if any), \r\n\t *       paging the results if so desired.</dd>\r\n\t *   <dt><code>Promise <b>count</b>(criteria)</code></dt>\r\n\t *   <dd>Counts the items that match the given <code>criteria</code> (if any). This count\r\n\t *       can be used to calculate the <code>pageIndex</code> parameters when using paging.</dd>\r\n\t *   <dt><code>Promise <b>save</b>(items)</code></dt>\r\n\t *   <dd>Adds new items to the store, or updates existing items.</dd>\r\n\t *   <dt><code>Promise <b>delete</b>(items)</code></dt>\r\n\t *   <dd>Permanently deletes items from the store.</dd>\r\n\t * </ul>\r\n\t * <p>All three methods return a <code>Promise</code> that resolves to an \r\n\t * 'immutable' array(-like) with the fetched, changed or deleted items in it.</p>\r\n\t * \r\n\t * <p>Furthermore, the store can be observed for changes by attaching a listener\r\n\t * to the <code>change</code> event using the <code>on</code> method:</p>\r\n\t * <code><pre>\r\n\t * myDataStore.on('change', function() {\r\n\t *   // The store has changed. \r\n\t * });\r\n\t * </pre></code>\r\n\t * <p>The listener(s) can be removed again using the <code>off</code> method:</p>\r\n\t * <code><pre>\r\n\t * myDataStore.off('change', myListener); // removes myListener from change event\r\n\t * myDataStore.off('change'); // removes all listeners from change event\r\n\t * </pre></code>\r\n\t * \r\n\t */\r\n\tvar DataStore = Class('DataStore', {\r\n\t\t\r\n\t\tinitialize: function DataStore_initialize(name, url, cfg) {\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.url = url || ''; // storetype://path/to/repository/store\r\n\t\t\tthis.cfg = cfg || {};\r\n\t\t\tthis.cfg.listeners = this.cfg.listeners || {};\r\n\t\t\tthis.cfg.throttle = this.cfg.throttle || {};\r\n\t\t},\r\n\t\t\r\n\t\ton: function DataStore_on(event, listener) {\r\n\t\t\tthis.cfg.listeners[event] = this.cfg.listeners[event] || [];\r\n\t\t\tthis.cfg.listeners[event].push(listener);\r\n\t\t},\r\n\r\n\t\ttrigger: function DataStore_trigger(event) {\r\n\t\t\tvar me = this, cfg = me.cfg, listeners = cfg.listeners[event];\r\n\t\t\tif (listeners) {\r\n\t\t\t\tif (! cfg.throttle[event]) {\r\n\t\t\t\t\tcfg.throttle[event] = {\r\n\t\t\t\t\t\ttriggered: Date.now()\r\n\t\t\t\t\t};\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tvar throttle = cfg.throttle[event];\r\n\t\t\t\tif (throttle.timeout &&\t(Date.now() < throttle.triggered + 250)) {\r\n\t\t\t\t\tclearTimeout(throttle.timeout);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthrottle.triggered = Date.now();\r\n\t\t\t\t}\r\n\t\t\t\tthrottle.timeout = setTimeout(function(){\r\n\t\t\t\t\tfor (var i=0,listener; listener=listeners[i]; i++) {\r\n\t\t\t\t\t\tlistener.call(me);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthrottle.timeout = null;\r\n\t\t\t\t}, 10);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\toff: function DataStore_off(event, listener) {\r\n\t\t\tif (this.cfg.listeners[event]) {\r\n\t\t\t\tif (listener) {\r\n\t\t\t\t\tfor (var i=this.cfg.listeners[event].length-1; i>=0; i--) {\r\n\t\t\t\t\t\tif (this.cfg.listeners[event][i] === listener) {\r\n\t\t\t\t\t\t\treturn this.cfg.listeners[event].splice(i, 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar results = this.cfg.listeners[event];\r\n\t\t\t\t\tdelete this.cfg.listeners[event];\r\n\t\t\t\t\treturn results;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n//      ABSTRACT-------------------------------------------------------------------------------------------\r\n//\t\t                    'abstract' methods each datastore should have.\r\n//      ---------------------------------------------------------------------------------------------------\r\n\r\n\t\t/**\r\n\t\t * Loads all items from this store matching the given <code>criteria</code>.\r\n\t\t * \r\n\t\t * <p>This method returns a <code>Promise</code> that resolves to an array(-like) that should be\r\n\t\t * treated as immutable. To mutate the store, use <code>save</code> and <code>delete</code>.</p>\r\n\t\t * \r\n\t\t * @param criteria Criteria to match on. Optional. Object.\r\n\t\t * @param pageSize Limits the number of results to fetch. Optional. Number.\r\n\t\t * @param pageIndex Indicates which results to fetch. Optional. Only applies when \r\n\t\t *        <code>pageSize &gt; 0</code>. Number. \r\n\t\t * \r\n\t\t * @return A <code>Promise<code> that resolves to an 'immutable' array of items, \r\n\t\t *         possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tload: function DataStore_load(criteria, pageSize, pageIndex) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve([]);\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Counts the items matching the given <code>criteria</code>.\r\n\t\t * \r\n\t\t * <p>This method returns a <code>Promise</code> that resolves to the number of items that match\r\n\t\t * the given <code>criteria</code>, or to the total number of items if no <code>criteria</code> \r\n\t\t * were given. Using this number (which will be typically obtained with an efficient operation\r\n\t\t * such as <code>SELECT COUNT(..)</code>) you can calculate the number of pages for a certain\r\n\t\t * <code>pageSize</code> and thus determine the valid range for the <code>pageIndex</code>\r\n\t\t * parameter of the <code>load</code> operation.</p>\r\n\t\t * \r\n\t\t * @param criteria Criteria to match on. Optional. Object.\r\n\t\t * \r\n\t\t * @return A <code>Promise<code> that resolves to an 'immutable' array of items, \r\n\t\t *         possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tcount: function DataStore_count(criteria) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(0);\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Saves the given <code>item</code>(s).\r\n\t\t * \r\n\t\t * <p>Returns a <code>Promise</code> that resolves to an 'immutable' array(-like) with the added \r\n\t\t * or changed items. These items may have changes compared with the given items (such as last \r\n\t\t * modified date, version etc) so the originals are stale after this method completes.</p> \r\n\t\t * \r\n\t\t * <p>The argument can be an instance of <code>Persistent</code> or an array(-like) of instances \r\n\t\t * of <code>Persistent.</code>. Multiple arguments can be given. These are all ways to save \r\n\t\t * three persistent objects <code>a</code>, <code>b</code> and <code>c</code>:</p>\r\n\t\t * \r\n\t\t * <code><pre>\r\n\t\t * myDataStore.save(a);\r\n\t\t * myDataStore.save(b);\r\n\t\t * myDataStore.save(c);\r\n\t\t * // or\r\n\t\t * myDataStore.save(a, b, c);\r\n\t\t * // or\r\n\t\t * myDataStore.save([a,b,c]);\r\n\t\t * // or\r\n\t\t * myDataStore.save(a, [b,c]);\r\n\t\t * // etc...\r\n\t\t * </pre></code>\r\n\t\t * \r\n\t\t * <p>If we need to wait for the result of the operation, we can do so like this:</p>\r\n\t\t * \r\n\t\t * <code><pre>\r\n\t\t * myDataStore.save(myItems).then(function(results){\r\n\t\t *    // Hooray! The items are saved!\r\n\t\t *    for (var i=0, item; item=results[i]; i++) { \r\n\t\t *       // do something kick-ass with this item\r\n\t\t *       alert('Yeah! ' + item + ' is saved!'); \r\n\t\t *    }\r\n\t\t * }).catch(function(e){\r\n\t\t *    // Oh no!! Something went wrong!\r\n\t\t *    alert('There was an error: ' + e);\r\n\t\t * });\r\n\t\t * </pre></code>\r\n\t\t * \r\n\t\t * \r\n\t\t * @param  item Either a single persistent item or an array(-like) of persistent items. \r\n\t\t * @return A <code>Promise</code> that resolves to an 'immutable' array of items that were added \r\n\t\t *         or changed. Possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tsave: function DataStore_save(item) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(item.length === undefined ? [item] : item);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Permanently deletes the given <code>item</code>s.\r\n\t\t * \r\n\t\t * <p>Returns a <code>Promise</code> that yields the removed items in an array(-like). \r\n\t\t * The returned array(-like) should be treated as immutable.</p>\r\n\t\t * \r\n\t\t * <p>The argument can be an instance of Persistent or an array(-like) of instances of Persistent. \r\n\t\t * Just like with <code>save()</code>, multiple arguments can be given.</p>\r\n\t\t * \r\n\t\t * @param  item Either a single persistent item or an array(-like) of persistent items. \r\n\t\t * @return An 'immutable' array of items that were removed. Possibly empty but never <code>null</code>.\r\n\t\t */\r\n\t\tdelete: function DataStore_delete(item) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve('length' in item ? item : [item]);\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n//      /ABSTRACT------------------------------------------------------------------------------------------\r\n\t\t\r\n\t\ttoString: function DataStore_toString() {\r\n\t\t\treturn '[Object ' + this.constructor.classname + ' \\'' + this.name + '\\' {url: \\'' + this.url + '\\'}]';\r\n\t\t}\r\n\t});\r\n\r\n\t/** Registry of datastore factories by type. */\r\n\tDataStore.typeFactories = {};\r\n\t\r\n\t/** Registers the datastore <code>factory</code> as 'protocol handler' for the given <code>type</code>. */\r\n\tDataStore.registerType = function DataStore_registerType(type, factory) {\r\n\t\tif (! DataStore.typeFactories[type]) {\r\n\t\t\tDataStore.typeFactories[type] = factory;\r\n\t\t}\r\n\t};\r\n\t\r\n\t/** Creates a new datastore from the given <code>type</code>. */\r\n\tDataStore.fromType = function DataStore_fromType(name, type, url, cfg) {\r\n\t\treturn DataStore.typeFactories[type](name, url, cfg);\r\n\t};\r\n\t\r\n\t/** Creates a new datastore from the given <code>url</code>. */\r\n\tDataStore.fromUrl = function DataStore_fromUrl(name, url, cfg) {\r\n\t\tif (! url) {return null;}\r\n\t\tvar idx = url.indexOf('://'),\r\n\t\t\ts = url.substring(0, idx), \r\n\t\t\ttype = s === 'https' ? 'http' : (s || 'http');\r\n\t\treturn DataStore.fromType(name, type, url, cfg);\r\n\t};\r\n\t\r\n\treturn DataStore;\r\n});\r\n\n","define('bridalapp/synchabledatastore',['suid', 'lang/class', 'bridalapp/datastore'], function (Suid, Class, DataStore) {\r\n\t'use strict';\r\n\t\r\n\t/**\r\n\t * 'Abstract' base class for local datastores that can synched with some backend.\r\n\t * \r\n\t * <p>The main API of synchable datastores is:</p>\r\n\t * \r\n\t * <dl>\r\n\t *   <dt><code>Boolean <b>lookSynched</b>()</code></dt>\r\n\t *   <dd>Indicates whether the datastore looks synched (from this end).</dd>\r\n\t *   <dt><code>Promise <b>synch</b>()</code></dt>\r\n\t *   <dd>Brings this datastore back into synch.</dd>\r\n\t *   <dt><code>Boolean <b>isSynching</b>()</code></dt>\r\n\t *   <dd>Indicates whether this datastore is currently busy synching.</dd>\r\n\t *   <dt><code>Array(-like) <b>items</b>()</code></dt>\r\n\t *   <dd>Returns an 'immutable' array(-like) that represents a live view of the items \r\n\t *       maintained in this store.</dd>\r\n\t *   <dt><code>Array <b>createdItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that have been added to the store since the last synch.</dd>\r\n\t *   <dt><code>Array <b>updatedItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that have been updated since the last synch.</dd>\r\n\t *   <dt><code>Array <b>deletedItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that have been deleted from the store since the last synch.</dd>\r\n\t *   <dt><code>Array <b>staleItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that could not be saved during the last synch because they went stale.</dd>\r\n\t *   <dt><code>Array <b>failedItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that could not be saved during the last synch because they had errors.</dd>\r\n\t *   <dt><code>Array <b>futureItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that were already updated when a synch started and were then updated again while synch was in progress.</dd>\r\n\t * </dl>\r\n\t * \r\n\t * <p>synchable datastores are assumed to have fast access to (a cache of) all data they maintain.\r\n\t * As such they provide a synchronous API for accessing and mutating the data in the datastore \r\n\t * that is easier to work with than the default asynchronous <code>load</code>, <code>count</code>, \r\n\t * <code>save</code> and <code>delete</code> methods:</p>\r\n\t * \r\n\t * <dl>\r\n\t *   <dt><code>Array get(criteria, pageSize, pageIndex)</code></dt>\r\n\t *   <dd>Synchronous equivalent of <code>load</code>.</dd>\r\n\t *   <dt><code>Number len(criteria)</code></dt>\r\n\t *   <dd>Synchronous equivalent of <code>count</code>.</dd>\r\n\t *   <dt><code>Array set(item)</code></dt>\r\n\t *   <dd>Synchronous equivalent of <code>save</code>.</dd>\r\n\t *   <dt><code>Array del(item)</code></dt>\r\n\t *   <dd>Synchronous equivalent of <code>delete</code>.</dd>\r\n\t * </dl>\r\n\t * \r\n\t * <p>The synchronous methods operate on the locally cached data. As such, the\r\n\t * methods <code>set</code> and <code>del</code> will usually make the datastore\r\n\t * <i>out of synch</i>. You can check whether the datastore still looks in synch\r\n\t * with <code>looksSynched</code> and bring it back in synch with <code>synch</code>.</p>\r\n\t * \r\n\t * <p>Unlike their asynchonous counterparts, the synchronous methods <code>set</code>\r\n\t * and <code>del</code> return the items unchanged, so essentially they can be\r\n\t * discarded.</p>\r\n\t */\r\n\tvar SynchableDataStore = Class('SynchableDataStore', DataStore, {\r\n\t\t\r\n\t\tinitialize: function SynchableDataStore_initialize($super, name, url, cfg) {\r\n\t\t\t$super(name, url, cfg);\r\n\t\t},\r\n\t\t\r\n\t\t/** \r\n\t\t * Synchronous equivalent of <code>load</code>.\r\n\t\t * \r\n\t\t * <p>No remote request will actually be fired. The filtering based on the\r\n\t\t * given <code>criteria</code> and the paging both happen client-side and\r\n\t\t * will be fast as long as the dataset is not too large.</p>\r\n\t\t */\r\n\t\tget: function SynchableDataStore_get(criteria, pageSize, pageIndex, clone) {\r\n\t\t\tvar items = clone ? Persistent.clone(this.items()) : this.items();\r\n\t\t\treturn Persistent.page(Persistent.matches(items, criteria), pageSize, pageIndex);\r\n\t\t},\r\n\r\n\t\t/** \r\n\t\t * Synchronous equivalent of <code>count</code>.\r\n\t\t *  \r\n\t\t * <p>No remote request will actually be fired. This method just calls\r\n\t\t * <code>get</code> with the given <code>criteria</code> and returns\r\n\t\t * the number of results it got.</p>\r\n\t\t */\r\n\t\tlen: function SynchableDataStore_len(criteria) {\r\n\t\t\treturn this.get(criteria).length;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Indicates whether this datastore looks synchronized (from this end). \r\n\t\t * \r\n\t\t * <p>This method will return <code>false</code> if there are any outstanding changes, \r\n\t\t * but this method returning <code>true</code> does not guarantee anything as it is \r\n\t\t * impossible to determine whether something was changed on the remote side without\r\n\t\t * actually making a request.\r\n\t\t */\r\n\t\tlooksSynched: function SynchableDataStore_looksSynched() {\r\n\t\t\t// if lastSynched == Date(0) (epoch) it means we are not synched\r\n\t\t\t// if there are any items in any of the lists it means we are not in synch\r\n\t\t\treturn (this.lastSynched().getTime() !== 0) && \r\n\t\t\t\t\t(! (this.createdItems().length || this.updatedItems().length || this.deletedItems().length));\r\n\t\t},\r\n\t\t\r\n\r\n//\t\tABSTRACT-------------------------------------------------------------------------\r\n//\t\t             'abstract' methods each synchable datastore should have\r\n//\t\t---------------------------------------------------------------------------------\r\n\t\t/** \r\n\t\t * Brings this datastore back into synch.\r\n\t\t * \r\n\t\t * <p>Returns a promise that resolves on synch complete or rejects on\r\n\t\t * synch failure. The arrays returned by <code>staleItems</code> and \r\n\t\t * <code>failedItems</code> will be updated with items that could not\r\n\t\t * be saved because they had been changed on the remote server in the\r\n\t\t * meantime, or that gave (integrity constraint) validation errors,\r\n\t\t * respectively.</p> \r\n\t\t */\r\n\t\tsynch: function SynchableDataStore_synch() {return new Promise(function(resolve){resolve();})},\r\n\r\n\t\t/** Indicates whether this datastore is currently busy synching. */\r\n\t\tisSynching: function SynchableDataStore_isSynching() {return false;},\r\n\t\t\r\n\t\t/** Gets or sets the (device) date time this datastore was last synched. */\r\n\t\tlastSynched: function SynchableDataStore_lastSynched(newDate) {return newDate || new Date();},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns an 'immutable' array that represents a live view of the items\r\n\t\t * maintained in this store. \r\n\t\t * \r\n\t\t * <p>The result of this method can be used for observing/monitoring the\r\n\t\t * data set. DO NOT MUTATE THIS ARRAY!.</p>\r\n\t\t */\r\n\t\titems: function SynchableDataStore_items() {},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that have been added to the store since the last synch. */\r\n\t\tcreatedItems: function SynchableDataStore_createdItems() {return [];},\r\n\t\t\r\n\t\t/** 'Immutable' array of the original versions of items that have been updated since the last synch. */\r\n\t\tupdatedItems: function SynchableDataStore_updatedItems() {return [];},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that have been deleted since the last synch. */\r\n\t\tdeletedItems: function SynchableDataStore_deletedItems() {return [];},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that could not be saved during the last synch because they went stale. */\r\n\t\tstaleItems: function SynchableDataStore_staleItems() {return [];},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that could not be saved during the last synch because they had errors. */\r\n\t\tfailedItems: function SynchableDataStore_failedItems() {return [];},\r\n\t\t\r\n\t\t/** \r\n\t\t * 'Immutable' array of items that were already updated when a synch started and were then updated again while synch was in progress.\r\n\t\t *  These items are effectively stale, but because the user edited his own items, we can safely assume\r\n\t\t *  he wishes to overwrite the remote version with the item that is in this list.\r\n\t\t */\r\n\t\tfutureItems: function SynchableDataStore_failedItems() {return [];},\r\n\r\n\t\t/** \r\n\t\t * Synchronous equivalent of <code>save</code>.\r\n\t\t * \r\n\t\t * <p>The arrays returned by <code>updatedItems</code>, <code>createdItems</code>\r\n\t\t * and <code>removedItems</code> will be updated to reflect the changes made\r\n\t\t * to the datastore since the last synch.</p>\r\n\t\t */\r\n\t\tset: function SynchableDataStore_set(item) {return item},\r\n\t\t\r\n\t\t/**\r\n\t\t * Synchronous equivalent of <code>delete</code>.\r\n\t\t *  \r\n\t\t * <p>The arrays returned by <code>updatedItems</code>, <code>createdItems</code>\r\n\t\t * and <code>removedItems</code> will be updated to reflect the changes made\r\n\t\t * to the datastore since the last synch.</p>\r\n\t\t */\r\n\t\tdel: function SynchableDataStore_del(item) {return item},\r\n//\t\t/ABSTRACT------------------------------------------------------------------------\r\n\t\t\r\n\t\ttoString: function SynchableDataStore_toString($super) {\r\n\t\t\tvar s = $super();\r\n\t\t\ts = s.substring(0, s.length - 2);\r\n\t\t\treturn '[Object ' + this.constructor.classname + ' \\'' + this.name + '\\' {' + \r\n\t\t\t\t\t'url: \\'' + this.url + '\\', ' + \r\n\t\t\t\t\t'lastSynched:' + this.lastSynched() + ', ' + \r\n\t\t\t\t\t'items:' + this.items().length + ', ' + \r\n\t\t\t\t\t'created:' + this.createdItems().length + ', ' + \r\n\t\t\t\t\t'updated:' + this.updatedItems().length + ', ' + \r\n\t\t\t\t\t'deleted:' + this.deletedItems().length + ', ' + \r\n\t\t\t\t\t'stale:' + this.staleItems().length + ', ' +\r\n\t\t\t\t\t'failed:' + this.failedItems().length + '}]';\r\n\t\t}\r\n\t});\r\n\t\r\n\t\r\n\treturn SynchableDataStore;\r\n});\r\n\n","define('bridalapp/synchrequest',['lang/class'], function(Class){\r\n\tvar SynchRequest = Class('SynchRequest', {\r\n\t\tinitialize: function(obj) {\r\n\t\t\tthis.unsynchedDuration = (obj && obj.synchDuration) || 0;\r\n\t\t\tthis.criteria = (obj && obj.criteria) || null;\r\n\t\t\tthis.currentIds = (obj && obj.currentIds) || [];\r\n\t\t\tthis.currentVersions = (obj && obj.currentVersions) || [];\r\n\t\t\tthis.createdItems = (obj && obj.createdItems) || [];\r\n\t\t\tthis.updatedItems = (obj && obj.updatedItems) || [];\r\n\t\t\tthis.deletedItems = (obj && obj.deletedItems) || [];\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn SynchRequest;\r\n});\n","define('bridalapp/synchresponse',['lang/class'], function(Class){\r\n\tvar SynchResponse = Class('SynchResponse', {\r\n\t\tinitialize: function(obj) {\r\n\t\t\tthis.createdItems = (obj && obj.createdItems) || [];\r\n\t\t\tthis.updatedItems = (obj && obj.updatedItems) || [];\r\n\t\t\tthis.staleItems = (obj && obj.staleItems) || [];\r\n\t\t\tthis.failedItems = (obj && obj.failedItems) || [];\r\n\t\t\tthis.deletedIds = (obj && obj.deletedIds) || [];\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn SynchResponse;\r\n});\n","define('bridalapp/syncheddatastore',['lang/class', \r\n\t\t'jquery', \r\n\t\t'bridalapp/log', \r\n\t\t'bridalapp/persistent', \r\n\t\t'bridalapp/datastore', \r\n\t\t'bridalapp/synchabledatastore', \r\n\t\t'bridalapp/synchrequest', \r\n\t\t'bridalapp/synchresponse'], \r\n\r\nfunction (Class, $, log, Persistent, DataStore, SynchableDataStore, SynchRequest, SynchResponse) {\r\n\t'use strict';\r\n\r\n\tvar SynchedDataStore = Class('SynchedDataStore', SynchableDataStore, {\r\n\t\t\r\n\t\tinitialize: function SynchedDataStore_initialize($super, name, url, cfg) {\r\n\t\t\t$super(name, url, cfg);\r\n\t\t\tthis.synching = false;\r\n\t\t\tthis.synchError = false;\r\n\t\t\tcfg = this.cfg;\r\n\t\t\tif (cfg.autoSynch === undefined) {cfg.autoSynch = true;}\r\n\t\t\tif (!cfg.synchInterval) {cfg.synchInterval = 30 * 1000;}    // 30 sec.\r\n\t\t\tif (!cfg.pollInterval) {cfg.pollInterval = 30 * 60 * 1000;} // 30 min.\r\n\t\t\tif (cfg.remoteSynch === undefined) {cfg.remoteSynch = true;}\r\n\t\t\tif ((! cfg.localDataStore) || (! cfg.remoteDataStore)) {\r\n\t\t\t\t// url: 'synched://rhaboo/bridal-app/ratings#http/api/ratings'\r\n\t\t\t\tvar urls = url.split('://')[1].split('#');\r\n\t\t\t\tif (! cfg.localDataStore) {\r\n\t\t\t\t\tvar localParts=urls[0].split('/'), \r\n\t\t\t\t\t\tlocalType=localParts[0],\r\n\t\t\t\t\t\tlocalRepo=localParts.slice(1, localParts.length-1).join('/'),\r\n\t\t\t\t\t\tlocalStore=localParts[localParts.length-1];\r\n\t\t\t\t\tcfg.localDataStore = DataStore.fromType(name, localType, \r\n\t\t\t\t\t\t\tlocalType + '://' + localRepo + '/' + localStore);\r\n\t\t\t\t\tif (! (cfg.localDataStore instanceof SynchableDataStore)) {\r\n\t\t\t\t\t\tif (cfg.localDataStore) {\r\n\t\t\t\t\t\t\tlog().error('Unable to initialize SynchedDataStore \\'' + name + '\\'.' + \r\n\t\t\t\t\t\t\t\t\t'Need a synchable datastore for the local side, ' + \r\n\t\t\t\t\t\t\t\t\t'but ' + cfg.localDataStore + ' is not a SynchableDataStore.');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tlog().error('Unable to initialize SynchedDataStore \\'' + name + '\\'.' + \r\n\t\t\t\t\t\t\t\t\t'Need a synchable datastore for the local side, but ' + \r\n\t\t\t\t\t\t\t\t\t'could not find a datastore for url \\'' + urls[0] + '\\'.');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (! cfg.remoteDataStore) {\r\n\t\t\t\t\tvar remoteParts=urls[1].split('/'),\r\n\t\t\t\t\t\tremoteType=remoteParts[0],\r\n\t\t\t\t\t\tremoteRepo=remoteParts.slice(1, remoteParts.length-1).join('/'),\r\n\t\t\t\t\t\tremoteStore=remoteParts[remoteParts.length-1];\r\n\t\t\t\t\tcfg.remoteDataStore = DataStore.fromType(name, remoteType, '/' + remoteRepo + '/' + remoteStore);\r\n\t\t\t\t\tif (! cfg.remoteDataStore) {\r\n\t\t\t\t\t\tlog().error('Unable to initialize SynchedDataStore \\'' + name + '\\'.' + \r\n\t\t\t\t\t\t\t\t'Need a datastore for the remote side, but ' + \r\n\t\t\t\t\t\t\t\t'could not find a datastore for url \\'' + urls[1] + '\\'.');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/** \r\n\t\t * Brings this datastore back into synch.\r\n\t\t * \r\n\t\t * <p>Returns a promise that resolves on synch complete or rejects on\r\n\t\t * synch failure. The arrays returned by <code>staleItems</code> and \r\n\t\t * <code>failedItems</code> will be updated with items that could not\r\n\t\t * be saved because they had been changed on the remote server in the\r\n\t\t * meantime, or that gave (integrity constraint) validation errors,\r\n\t\t * respectively.</p> \r\n\t\t */\r\n\t\tsynch: function SynchedDataStore_synch($super) {\r\n\t\t\tif (this.cfg.autoSynch) {autoSynch(this);}\r\n\t\t\tvar me = this, cfg = me.cfg;\r\n\t\t\tif (me.synching) {return me.synching;}\r\n\t\t\tme.synchError = false;\r\n\t\t\tif (! cfg.remoteDataStore.cfg.supportsSynch) {return poorMansSynch(me);}\r\n\t\t\treturn me.synching = new Promise(function(resolve, reject) {\r\n\t\t\t\t// if store looks synched and poll interval not expired, do nothing.\r\n\t\t\t\tif (me.looksSynched() && (Date.now() < me.lastSynched().getTime() + cfg.pollInterval)) {\r\n\t\t\t\t\t// postpone resolving until after synch method has returned.\r\n\t\t\t\t\treturn setTimeout(function(){\r\n\t\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t},0);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// synching is needed\r\n\t\t\t\tme.trigger('synch:started');\r\n\t\t\t\tvar changed = false;\r\n\t\t\t\tvar req = new SynchRequest();\r\n\t\t\t\treq.criteria = cfg.filter || null;\r\n\t\t\t\treq.createdItems.push.apply(req.createdItems, me.createdItems());\r\n\t\t\t\treq.updatedItems.push.apply(req.updatedItems, me.updatedItems());\r\n\t\t\t\treq.deletedItems.push.apply(req.deletedItems, me.deletedItems());\r\n\t\t\t\treq.currentIds.push.apply(req.currentIds, Persistent.pluck(me.items(), 'id'));\r\n\t\t\t\treq.currentVersions.push.apply(req.currentVersions, Persistent.pluck(me.items(), 'version'));\r\n\r\n\t\t\t\tcfg.remoteDataStore.synch(req).then(function(response) {\r\n\t\t\t\t\tvar i,id,idx,item;\r\n\r\n\t\t\t\t\t// handle deleted items\r\n\t\t\t\t\tif (response.deletedIds.length) {\r\n\t\t\t\t\t\tfor (i=0; id=response.deletedIds[i]; i++) {\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.items(), id);\r\n\t\t\t\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t\t\t\tme.items().splice(idx, 1);\r\n\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.deletedItems(), id);\r\n\t\t\t\t\t\t\tif (idx !== -1) {me.deletedItems().splice(idx, 1);}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.deletedIds.length + ' deleted items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// handle updated items\r\n\t\t\t\t\tif (response.updatedItems.length) {\r\n\t\t\t\t\t\tfor (i=0; item=response.updatedItems[i]; i++) {\r\n\t\t\t\t\t\t\t// if we have futureItems, try to merge the changes into the new version of the item\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.futureItems(), item)\r\n\t\t\t\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t\t\t\t// get future item and remove from list\r\n\t\t\t\t\t\t\t\tvar future = me.futureItems().splice(idx, 1)[0];\r\n\t\t\t\t\t\t\t\t// replace updated item with version from server\r\n\t\t\t\t\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\t\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1, item);}\r\n\t\t\t\t\t\t\t\telse {me.updatedItems().push(item);}\r\n\t\t\t\t\t\t\t\t// now merge changes from future item onto server item\r\n\t\t\t\t\t\t\t\tvar merged = Persistent.clone(item);\r\n\t\t\t\t\t\t\t\tfor (var key in future) {\r\n\t\t\t\t\t\t\t\t\tif (key !== 'version') {\r\n\t\t\t\t\t\t\t\t\t\tmerged[key] = future[key]; \r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// replace item with the merged version\r\n\t\t\t\t\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\t\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t\t\t\t\tme.items().splice(idx, 1, merged);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t// remove saved item from the updatedItems list\r\n\t\t\t\t\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\t\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1);}\r\n\t\t\t\t\t\t\t\telse {changed = true;}\r\n\t\t\t\t\t\t\t\t// replace item with the saved version\r\n\t\t\t\t\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\t\t\t\t\tif (idx !== -1) {me.items().splice(idx, 1, item);}\r\n\t\t\t\t\t\t\t\telse {me.items().push(item);}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.updatedItems.length + ' updated items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// handle created items\r\n\t\t\t\t\tif (response.createdItems.length) {\r\n\t\t\t\t\t\tfor (i=0; item=response.createdItems[i]; i++) {\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\t\t\t\tif (idx === -1) {\r\n\t\t\t\t\t\t\t\tme.items().push(item);\r\n\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {me.items().splice(idx, 1, item);}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.createdItems.length + ' created items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// handle stale items\r\n\t\t\t\t\tif (response.staleItems.length) {\r\n\t\t\t\t\t\tfor (i=0; item=response.staleItems[i]; i++) {\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.staleItems(), item);\r\n\t\t\t\t\t\t\tif (idx === -1) {me.staleItems().push(item);}\r\n\t\t\t\t\t\t\telse {me.staleItems().splice(idx, 1, item);}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.staleItems.length + ' stale items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (response.failedItems.length) {\r\n\t\t\t\t\t\t// handle failed items\r\n\t\t\t\t\t\tfor (i=0; item=response.failedItems[i]; i++) {\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.failedItems(), item);\r\n\t\t\t\t\t\t\tif (idx === -1) {me.failedItems().push(item);}\r\n\t\t\t\t\t\t\telse {me.failedItems().splice(idx, 1, item);}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.failedItems.length + ' failed items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tme.lastSynched(new Date());\r\n\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\tif (changed) {me.trigger('change');} \r\n\t\t\t\t\tme.trigger('synch:success');\r\n\t\t\t\t\tresolve();\r\n\t\t\t\t\tme.trigger('synch:done');\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\tme.synchError = e;\r\n\t\t\t\t\tme.trigger('synch:failed');\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t\tme.trigger('synch:done');\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/** Indicates whether this datastore is currently busy synching. */\r\n\t\tisSynching: function SynchedDataStore_isSynching() {\r\n\t\t\treturn !!this.synching;\r\n\t\t},\r\n\r\n\t\t// IMPLEMENT ALL ABSTRACT METHODS.\r\n\t\t// ASYNCH methods will call synch to try to make sure after the call the results\r\n\t\t// are consistent for both the local as well as the remote datastore.\r\n\t\tload: function SynchedDataStore_load(criteria, pageSize, pageIndex) {\r\n\t\t\tvar me = this;\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tthis.synch().then(function(){\r\n\t\t\t\t\tme.cfg.localDataStore.load(criteria, pageSize, pageIndex).then(function(items){\r\n\t\t\t\t\t\tresolve(items);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}); \r\n\t\t},\r\n\r\n\t\tcount: function SynchedDataStore_count(criteria) {\r\n\t\t\tvar me = this;\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tthis.synch().then(function(){\r\n\t\t\t\t\tme.cfg.localDataStore.count(criteria, pageSize, pageIndex).then(function(count){\r\n\t\t\t\t\t\tresolve(count);\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}); \r\n\t\t},\r\n\r\n\t\tsave: function SynchedDataStore_save(item) {\r\n\t\t\tvar me = this;\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tme.cfg.localDataStore.save(item).then(function(items){\r\n\t\t\t\t\tme.synch().then(function(){\r\n\t\t\t\t\t\tresolve(items);\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}); \r\n\t\t},\r\n\r\n\t\tdelete: function SynchedDataStore_delete(item) {\r\n\t\t\tvar me = this;\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tme.cfg.localDataStore.delete(item).then(function(items){\r\n\t\t\t\t\tme.synch().then(function(){\r\n\t\t\t\t\t\tresolve(items);\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}); \r\n\t\t},\r\n\t\t\r\n\t\t// synchronous methods will interact with the local datastore only (remote does not support synchronous invocation)\r\n\t\t/** Gets or sets the (local/device) date time this datastore was last synched. */\r\n\t\tlastSynched: function SynchedDataStore_lastSynched(newDate) {\r\n\t\t\treturn this.cfg.localDataStore.lastSynched(newDate);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns an 'immutable' array that represents a live view of the items\r\n\t\t * maintained in this store. \r\n\t\t * \r\n\t\t * <p>The result of this method can be used for observing/monitoring the\r\n\t\t * data set. DO NOT MUTATE THIS ARRAY!.</p>\r\n\t\t */\r\n\t\titems: function SynchedDataStore_items() {\r\n\t\t\treturn this.cfg.localDataStore.items();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that have been added to the store since the last synch. */\r\n\t\tcreatedItems: function SynchedDataStore_createdItems() {\r\n\t\t\treturn this.cfg.localDataStore.createdItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of the original versions of items that have been updated since the last synch. */\r\n\t\tupdatedItems: function SynchedDataStore_updatedItems() {\r\n\t\t\treturn this.cfg.localDataStore.updatedItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that have been deleted since the last synch. */\r\n\t\tdeletedItems: function SynchedDataStore_deletedItems() {\r\n\t\t\treturn this.cfg.localDataStore.deletedItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that could not be saved during the last synch because they went stale. */\r\n\t\tstaleItems: function SynchedDataStore_staleItems() {\r\n\t\t\treturn this.cfg.localDataStore.staleItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that could not be saved during the last synch because they had errors. */\r\n\t\tfailedItems: function SynchedDataStore_failedItems() {\r\n\t\t\treturn this.cfg.localDataStore.failedItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** \r\n\t\t * 'Immutable' array of items that were already updated when a synch started and were then updated again while synch was in progress.\r\n\t\t *  These items are effectively stale, but because the user edited his own items, we can safely assume\r\n\t\t *  he wishes to overwrite the remote version with the item that is in this list.\r\n\t\t */\r\n\t\tfutureItems: function SynchedDataStore_futureItems() {\r\n\t\t\treturn this.cfg.localDataStore.futureItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** \r\n\t\t * Synchronous equivalent of <code>save</code>.\r\n\t\t * \r\n\t\t * <p>The arrays returned by <code>updatedItems</code>, <code>createdItems</code>\r\n\t\t * and <code>removedItems</code> will be updated to reflect the changes made\r\n\t\t * to the datastore since the last synch.</p>\r\n\t\t */\r\n\t\tset: function SynchedDataStore_set(item) {\r\n\t\t\treturn this.cfg.localDataStore.set(item);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Synchronous equivalent of <code>delete</code>.\r\n\t\t *  \r\n\t\t * <p>The arrays returned by <code>updatedItems</code>, <code>createdItems</code>\r\n\t\t * and <code>removedItems</code> will be updated to reflect the changes made\r\n\t\t * to the datastore since the last synch.</p>\r\n\t\t */\r\n\t\tdel: function SynchedDataStore_del(item) {\r\n\t\t\treturn this.cfg.localDataStore.del(item);\r\n\t\t}\r\n\t});\r\n\r\n\tDataStore.registerType('synched', function SynchedDataStoreFactory(name, url, cfg) {\r\n\t\treturn new SynchedDataStore(name, url, cfg);\r\n\t});\r\n\t\r\n\tfunction handleLoadedItems(me, items) {\r\n\t\tvar item, old, idx, changed=false;\r\n\t\t// all items we got from the remote should be added if we did not have them on local,\r\n\t\t// or updated locally if the version we got from the remote was different. only the \r\n\t\t// remote updates the version, so it being different means our version is older.\r\n\t\tfor (var i=0; item=items[i]; i++) {\r\n\t\t\tidx = Persistent.indexOf(me.items(), item); \r\n\t\t\tif (idx === -1) {\r\n\t\t\t\t// item is not in local. either it's new on remote, or was deleted on local\r\n\t\t\t\tidx = Persistent.indexOf(me.deletedItems(), item);\r\n\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t// item was deleted on local. check version\r\n\t\t\t\t\tif (item.version !== me.deletedItems()[idx].version) {\r\n\t\t\t\t\t\t// item was deleted locally, but edited on server, so our deleted\r\n\t\t\t\t\t\t// version becomes stale, but as we deleted it we don't care and\r\n\t\t\t\t\t\t// don't add it to stale. We just remove it from deletedItems.\r\n\t\t\t\t\t\tme.deletedItems().splice(idx, 1);\r\n\t\t\t\t\t\t// add the new version of the item we had deleted\r\n\t\t\t\t\t\tme.items().push(item);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// item is new on remote\r\n\t\t\t\t\tme.items().push(item);\r\n\t\t\t\t}\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// item is already in local. check version\r\n\t\t\t\tif (item.version !== me.items()[idx].version) {\r\n\t\t\t\t\t// local version is older than remote version. replace\r\n\t\t\t\t\told = me.items().splice(idx, 1, item)[0]; \r\n\t\t\t\t\t// if we had updated this item, the update went stale\r\n\t\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), old); \r\n\t\t\t\t\tif (idx !== -1){\r\n\t\t\t\t\t\t// changed item was updated, so went stale\r\n\t\t\t\t\t\tme.updatedItems().splice(idx, 1);\r\n\t\t\t\t\t\tidx = Persistent.indexOf(me.staleItems(), old); \r\n\t\t\t\t\t\tif (idx === -1) {me.staleItems().push(old);}\r\n\t\t\t\t\t\telse {me.staleItems().splice(idx, 1, old);}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tchanged = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// all items we did NOT get from the remote should be removed locally, \r\n\t\t// except for newly created ones\r\n\t\tfor (var i=me.items().length-1; i>=0; i--) {\r\n\t\t\titem = me.items()[i];\r\n\t\t\tif ((Persistent.indexOf(items, item) === -1) &&\r\n\t\t\t\t(Persistent.indexOf(me.createdItems(), item) === -1)){ \r\n\t\t\t\t// item is not new, but does not exist (any more) on the remote\r\n\t\t\t\tvar old = me.items().splice(i, 1)[0];\r\n\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), old);\r\n\t\t\t\tif (idx !== -1) { \r\n\t\t\t\t\t// removed item was updated locally, so went stale\r\n\t\t\t\t\tthis.updatedItems().splice(idx, 1);\r\n\t\t\t\t\tidx = Persistent.indexOf(me.staleItems(), old); \r\n\t\t\t\t\tif (staleIdx === -1) {me.staleItems().push(old);}\r\n\t\t\t\t\telse {me.staleItems().splice(idx, 1, old);}\r\n\t\t\t\t}\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (changed) {me.trigger('change');}\r\n\t}\r\n\r\n\tfunction handleSavedItems(me, items) {\r\n\t\tfor (var i=0,item; item=items[i]; i++) {\r\n\t\t\t// if we have futureItems, try to merge the changes into the new version of the item\r\n\t\t\tvar idx = Persistent.indexOf(me.futureItems(), item)\r\n\t\t\tif (idx !== -1) {\r\n\t\t\t\tvar future = me.futureItems().splice(idx, 1)[0];\r\n\t\t\t\t// replace updatedItems with version from server\r\n\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1, item);}\r\n\t\t\t\telse {me.updatedItems().push(item);}\r\n\t\t\t\t// now merge changes from future item onto server item\r\n\t\t\t\tvar merged = Persistent.clone(item);\r\n\t\t\t\tfor (var key in future) {\r\n\t\t\t\t\tif (key !== 'version') {\r\n\t\t\t\t\t\tmerged[key] = future[key]; \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// replace items with the merged version\r\n\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\tif (idx !== -1) {me.items().splice(idx, 1, merged);}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// remove saved item from the updatedItems list\r\n\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1);}\r\n\t\t\t\t// replace items with the saved version\r\n\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\tif (idx !== -1) {me.items().splice(idx, 1, item);}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction handleDeletedItems(me, items) {\r\n\t\tfor (var i=0,item; item=items[i]; i++) {\r\n\t\t\tvar idx = Persistent.indexOf(me.deletedItems(), item);\r\n\t\t\tif (idx !== -1) {me.deletedItems().splice(idx, 1);}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction poorMansSynch(me) {\r\n\t\tvar cfg = me.cfg;\r\n\t\treturn me.synching = new Promise(function(resolve, reject) {\r\n\t\t\t// if store looks synched and poll interval not expired, do nothing.\r\n\t\t\tif (me.looksSynched() && (Date.now() < me.lastSynched().getTime() + cfg.pollInterval)) {\r\n\t\t\t\t// postpone resolving until after synch method has returned.\r\n\t\t\t\treturn setTimeout(function(){\r\n\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\tresolve();\r\n\t\t\t\t},0);\r\n\t\t\t}\r\n\t\t\t// synching is needed\r\n\t\t\tme.trigger('synch:started');\r\n\t\t\tcfg.remoteDataStore.load().then(function(items) {\r\n\t\t\t\t// handle loaded items, save dirty items and delete removed items\r\n\t\t\t\thandleLoadedItems(me, items);\r\n\t\t\t\t// now that we processed all loaded items we can save our changes.\r\n\t\t\t\t// Make a snapshot of current state: dirty and deleted items.\r\n\t\t\t\tvar dirty = me.createdItems().concat();\r\n\t\t\t\tfor (var i=0,item; item=me.updatedItems()[i]; i++) {\r\n\t\t\t\t\t// The items in updated are the old versions, so get the corresponding new version\r\n\t\t\t\t\tvar idx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\t\tif (idx !== -1) {dirty.push(me.items()[idx]);}\r\n\t\t\t\t}\r\n\t\t\t\tvar deleted = me.deletedItems().concat();\r\n\t\t\t\t// delete items first\r\n\t\t\t\tnew Promise(function(resolve, reject){\r\n\t\t\t\t\tif (! deleted.length) {resolve(); return;}\r\n\t\t\t\t\tcfg.remoteDataStore.delete(deleted).then(function(items){\r\n\t\t\t\t\t\thandleDeletedItems(me, items);\r\n\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).then(function(){\r\n\t\t\t\t\t// items are deleted, now we can create new, or update\r\n\t\t\t\t\tnew Promise(function(resolve, reject){\r\n\t\t\t\t\t\tif (! dirty.length) {resolve(); return;}\r\n\t\t\t\t\t\tcfg.remoteDataStore.save(dirty).then(function(items){\r\n\t\t\t\t\t\t\thandleSavedItems(me, items);\r\n\t\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}).then(function(){\r\n\t\t\t\t\t\tme.lastSynched(new Date());\r\n\t\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\t\tme.synchError = false;\r\n\t\t\t\t\t\tme.trigger('synch:success');\r\n\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t\tme.trigger('synch:done');\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}).catch(function(e) {\r\n\t\t\t\t// load failed\r\n\t\t\t\tme.synching = false;\r\n\t\t\t\tme.synchError = e;\r\n\t\t\t\tme.trigger('synch:failed');\r\n\t\t\t\treject(e);\r\n\t\t\t\tme.trigger('synch:done');\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\tfunction autoSynch(me) {\r\n\t\tif (! me.autoSynchActive) {\r\n\t\t\tme.autoSynchActive = true;\r\n\t\t\tsetInterval(function(){\r\n\t\t\t\tme.synch();\r\n\t\t\t}, me.cfg.synchInterval);\r\n\t\t}\r\n\t}\r\n\r\n\treturn SynchedDataStore;\r\n});\r\n\n","define('bridalapp/rhaboodatastore',['lang/class',\r\n\t\t'bridalapp/datastore', \r\n\t\t'bridalapp/synchabledatastore', \r\n\t\t'bridalapp/persistent', \r\n\t\t'rhaboo'], \r\nfunction (Class, DataStore, SynchableDataStore, Persistent) {\r\n\t'use strict';\r\n\t\r\n\tvar RhabooDataStore = Class('RhabooDataStore', SynchableDataStore, {\r\n\r\n\t\tinitialize: function RhabooDataStore_initialize($super, name, url, cfg) {\r\n\t\t\t$super(name, url, cfg);\r\n\t\t\tif (!this.cfg.rhaboo || !this.cfg.store) { \r\n\t\t\t\tvar repoIdx = url.indexOf('://') + 3,\r\n\t\t\t\t\tstoreIdx = url.lastIndexOf('/'),\r\n\t\t\t\t\trepo = url.substring(repoIdx, storeIdx),\r\n\t\t\t\t\tstore = url.substring(storeIdx + 1);\r\n\t\t\t\tif (!this.cfg.repo) {this.cfg.repo = repo;}\r\n\t\t\t\tif (!this.cfg.store) {this.cfg.store = store;}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Loads all items from this store matching the given <code>criteria</code>.\r\n\t\t * \r\n\t\t * <p>This method returns a <code>Promise</code> that resolves to an array(-like) that should be\r\n\t\t * treated as immutable. To mutate the store, use <code>save</code> and <code>delete</code>.</p>\r\n\t\t * \r\n\t\t * @param criteria Criteria to match on. Optional. Object.\r\n\t\t * @param pageSize Limits the number of results to fetch. Optional. Number.\r\n\t\t * @param pageIndex Indicates which results to fetch. Optional. Only applies when \r\n\t\t *        <code>pageSize &gt; 0</code>. Number. \r\n\t\t * \r\n\t\t * @return A <code>Promise<code> that resolves to an 'immutable' array of items, \r\n\t\t *         possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tload: function DataStore_load(criteria, pageSize, pageIndex) {\r\n\t\t\tvar store = this;\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(this.get(criteria, pageSize, pageIndex));\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Counts the items matching the given <code>criteria</code>.\r\n\t\t * \r\n\t\t * <p>This method returns a <code>Promise</code> that resolves to the number of items that match\r\n\t\t * the given <code>criteria</code>, or to the total number of items if no <code>criteria</code> \r\n\t\t * were given. Using this number (which will be typically obtained with an efficient operation\r\n\t\t * such as <code>SELECT COUNT(..)</code>) you can calculate the number of pages for a certain\r\n\t\t * <code>pageSize</code> and thus determine the valid range for the <code>pageIndex</code>\r\n\t\t * parameter of the <code>load</code> operation.</p>\r\n\t\t * \r\n\t\t * @param criteria Criteria to match on. Optional. Object.\r\n\t\t * \r\n\t\t * @return A <code>Promise<code> that resolves to an 'immutable' array of items, \r\n\t\t *         possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tcount: function DataStore_count(criteria) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(this.len());\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Saves the given <code>item</code>(s).\r\n\t\t * \r\n\t\t * <p>Returns a <code>Promise</code> that resolves to an 'immutable' array(-like) with the added \r\n\t\t * or changed items. These items may have changes compared with the given items (such as last \r\n\t\t * modified date, version etc) so the originals are stale after this method completes.</p> \r\n\t\t * \r\n\t\t * <p>The argument can be an instance of <code>Persistent</code> or an array(-like) of instances \r\n\t\t * of <code>Persistent.</code>. Multiple arguments can be given. These are all ways to save \r\n\t\t * three persistent objects <code>a</code>, <code>b</code> and <code>c</code> (though they\r\n\t\t * differ in performance, bundling calls is quicker)</p>:\r\n\t\t * \r\n\t\t * <code><pre>\r\n\t\t * myDataStore.save(a);\r\n\t\t * myDataStore.save(b);\r\n\t\t * myDataStore.save(c);\r\n\t\t * // or\r\n\t\t * myDataStore.save(a, b, c);\r\n\t\t * // or\r\n\t\t * myDataStore.save([a,b,c]);\r\n\t\t * // or\r\n\t\t * myDataStore.save(a, [b,c]);\r\n\t\t * // etc...\r\n\t\t * </pre></code>\r\n\t\t * \r\n\t\t * <p>If we need to wait for the result of the operation, we can do so like this:</p>\r\n\t\t * \r\n\t\t * <code><pre>\r\n\t\t * myDataStore.save(myItems).then(function(results){\r\n\t\t *    // Hooray! The items are saved!\r\n\t\t *    for (var i=0, item; item=results[i]; i++) { \r\n\t\t *       // do something kick-ass with this item\r\n\t\t *       alert('Yeah! ' + item + ' is saved!'); \r\n\t\t *    }\r\n\t\t * }).catch(function(e){\r\n\t\t *    // Oh no!! Something went wrong!\r\n\t\t *    alert('There was an error: ' + e);\r\n\t\t * });\r\n\t\t * </pre></code>\r\n\t\t * \r\n\t\t * \r\n\t\t * @param  item Either a single persistent item or an array(-like) of persistent items. \r\n\t\t * @return A <code>Promise</code> that resolves to an 'immutable' array of items that were added \r\n\t\t *         or changed. Possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tsave: function DataStore_save(item) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(this.set(item));\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Permanently deletes the given <code>item</code>s.\r\n\t\t * \r\n\t\t * <p>Returns a <code>Promise</code> that yields the removed items in an array(-like). \r\n\t\t * The returned array(-like) should be treated as immutable.</p>\r\n\t\t * \r\n\t\t * <p>The argument can be an instance of Persistent or an array(-like) of instances of Persistent. \r\n\t\t * Just like with <code>save()</code>, multiple arguments can be given.</p>\r\n\t\t * \r\n\t\t * @param  item Either a single persistent item or an array(-like) of persistent items. \r\n\t\t * @return An 'immutable' array of items that were removed. Possibly empty but never <code>null</code>.\r\n\t\t */\r\n\t\tdelete: function DataStore_delete(item) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(this.del(item));\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\tset: function RhabooDataStore_set(item) {\r\n\t\t\tvar results = Persistent.eachArg(arguments, this, function(item) {\r\n\t\t\t\tvar backup = null,\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().items, item);\r\n\t\t\t\tif (idx === -1) {this.db().items.push(item);} \r\n\t\t\t\telse {backup = this.db().items.splice(idx, 1, item)[0];}\r\n\t\t\t\t\r\n\t\t\t\t// item had been deleted previously?\r\n\t\t\t\tidx = Persistent.indexOf(this.db().deleted, item);\r\n\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t// item was deleted, then added again, so effectively it was updated.\r\n\t\t\t\t\tbackup = this.db().deleted.splice(idx, 1);\r\n\t\t\t\t}\r\n\t\t\t\tif (backup) {\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().updated, item);\r\n\t\t\t\t\tif (idx === -1) {this.db().updated.push(backup);}\r\n\t\t\t\t\telse if (this.synching) {\r\n\t\t\t\t\t\t// the synch is already in progress... meaning when we get back the saved\r\n\t\t\t\t\t\t// item our new version would appear stale... So put it in future list\r\n\t\t\t\t\t\tidx = Persistent.indexOf(this.db().future, item);\r\n\t\t\t\t\t\tif (idx === -1) {this.db().future.push(item);}\r\n\t\t\t\t\t\telse {this.db().future.splice(idx, 1, item);}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn [item];\r\n\t\t\t});\r\n\t\t\tthis.trigger('change');\r\n\t\t\treturn results;\r\n\t\t},\r\n\r\n\t\tdel: function RhabooDataStore_del(item) {\r\n\t\t\tvar results = Persistent.eachArg(arguments, this, function(item) {\r\n\t\t\t\tvar backup, idx = Persistent.indexOf(this.items(), item);\r\n\t\t\t\tif (idx !== -1) {backup = this.items().splice(idx, 1)[0];}\r\n\t\t\t\tif (Persistent.persistent(item)) {\r\n\t\t\t\t\t// if item was in updated list, remove it\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().updated, item);\r\n\t\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t\tvar removed = this.db().updated.splice(idx, 1);\r\n\t\t\t\t\t\tbackup = backup || removed;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if item was in future list, remove it\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().future, item);\r\n\t\t\t\t\tif (idx !== -1) {this.db().future.splice(idx, 1);}\r\n\t\t\t\t\t// if item was not in deleted list, add it (old version if we have it)\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().deleted, item);\r\n\t\t\t\t\tif (idx === -1) {this.db().deleted.push(backup || item);}\r\n\t\t\t\t}\r\n\t\t\t\treturn [backup || item];\r\n\t\t\t});\r\n\t\t\tthis.trigger('change');\r\n\t\t\treturn results;\r\n\t\t},\r\n\t\t\r\n\t\t/** Gets or sets the (device) date time this store was last synched. */\r\n\t\tlastSynched: function RhabooDataStore_lastSynched(date) {\r\n\t\t\tif (date) {this.db().write('lastSynched', date);}\r\n\t\t\treturn this.db().lastSynched;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns an 'immutable' array that represents a live view of the items\r\n\t\t * maintained in this store. \r\n\t\t * \r\n\t\t * <p>The result of this method can be used for observing/monitoring the\r\n\t\t * data set. DO NOT MUTATE THIS ARRAY!.</p>\r\n\t\t */\r\n\t\titems: function RhabooDataStore_items() {\r\n\t\t\treturn this.db().items;\r\n\t\t},\r\n\r\n\t\t/** List of created items is calculated dynamically based on which items are not persistent yet */\r\n\t\tcreatedItems: function RhabooDataStore_createdItems() {\r\n\t\t\tvar results = [];\r\n\t\t\tfor (var i=0, item; item=this.items()[i]; i++) {\r\n\t\t\t\tif (! Persistent.persistent(item)) {results.push(item);}\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t},\r\n\t\t\r\n\t\tupdatedItems: function RhabooDataStore_updatedItems() {\r\n\t\t\treturn this.db().updated;\r\n\t\t},\r\n\t\t\r\n\t\tdeletedItems: function RhabooDataStore_deletedItems() {\r\n\t\t\treturn this.db().deleted;\r\n\t\t},\r\n\r\n\t\tstaleItems: function RhabooDataStore_staleItems() {\r\n\t\t\treturn this.db().stale;\r\n\t\t},\r\n\t\t\r\n\t\tfailedItems: function RhabooDataStore_failedItems() {\r\n\t\t\treturn this.db().failed;\r\n\t\t},\r\n\t\t\r\n\t\tfutureItems: function RhabooDataStore_futureItems() {\r\n\t\t\treturn this.db().future;\r\n\t\t},\r\n\t\t\r\n\t\tdb: function RhabooDataStore_db() {\r\n\t\t\tif (! this.cfg.rhaboo) {\r\n\t\t\t\tthis.cfg.rhaboo = Rhaboo.persistent(this.cfg.repo);\r\n\t\t\t\tif (! this.cfg.rhaboo[this.cfg.store]) {this.cfg.rhaboo.write(this.cfg.store, {});}\r\n\t\t\t\tfor (var i=0,key; key=['items', 'updated', 'deleted', 'stale', 'failed', 'future'][i]; i++) {\r\n\t\t\t\t\tif (! this.db()[key]) {this.db().write(key, []);}\r\n\t\t\t\t}\r\n\t\t\t\tif(! this.db().lastSynched) {this.db().write('lastSynched', new Date(0));}\r\n\t\t\t}\r\n\t\t\treturn this.cfg.rhaboo[this.cfg.store];\r\n\t\t}\r\n\t});\r\n\t\r\n\tDataStore.registerType('rhaboo', function RhabooDataStoreFactory(name, url, cfg) {\r\n\t\treturn new RhabooDataStore(name, url, cfg);\r\n\t});\r\n\t\r\n\treturn RhabooDataStore;\r\n});\r\n\n","define('bridalapp/restdatastore',['lang/class', 'jquery', 'bridalapp/log', 'bridalapp/persistent', 'bridalapp/datastore'], function (Class, $, log, Persistent, DataStore) {\r\n\t'use strict';\r\n\t\r\n\tvar RestDataStore = Class('RestDataStore', DataStore, {\r\n\t\t\r\n\t\tinitialize: function RestDataStore_initialize($super, name, url, cfg) {\r\n\t\t\t$super(name, url, cfg);\r\n\t\t\tthis.cfg.retryCount = this.cfg.retryCount || 0;\r\n\t\t\tthis.cfg.retryWaitTime = this.cfg.retryWaitTime || 2000;\r\n\t\t\tthis.cfg.timeout = this.cfg.timeout || 10000;\r\n\t\t\tif (this.cfg.supportsSynch === undefined) {this.cfg.supportsSynch = false}\r\n\t\t},\r\n\r\n\t\tload: function RestDataStore_load(criteria, pageSize, pageIndex) {\r\n\t\t\t// TODO add criteria and paging parameters to the url\r\n\t\t\treturn this.remoteRequest('GET', this.url, {criteria: criteria, pageSize: pageSize, pageIndex: pageIndex});\r\n\t\t},\r\n\r\n\t\tcount: function RestDataStore_count(criteria) {\r\n\t\t\t// TODO do the right thing and implement a count query\r\n\t\t\t// needs work on the server side as well and not needed yet\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tthis.remoteRequest('GET', this.url, {criteria: criteria}).then(function(items){\r\n\t\t\t\t\tresolve(items.length);\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t});  \r\n\t\t},\r\n\r\n\t\tsave: function RestDataStore_save(items) {\r\n\t\t\tvar all = Persistent.eachArg(items, this, function(item){return [item];});\r\n\t\t\treturn this.remoteRequest('POST', this.url + '/save', all);\r\n\t\t},\r\n\r\n\t\tdelete: function RestDataStore_delete(items) {\r\n\t\t\tvar all = Persistent.eachArg(items, this, function(item){return [item];});\r\n\t\t\treturn this.remoteRequest('DELETE', this.url, all);\r\n\t\t},\r\n\r\n\t\tsynch: function RestDataStore_synch(synchRequest) {\r\n\t\t\treturn this.remoteRequest('POST', this.url + '/synch', synchRequest);\r\n\t\t},\r\n\r\n\t\tremoteRequest: function RestDataStore_remoteRequest(method, url, data) {\r\n\t\t\treturn (function(method, url, data, timeout, retries, retryWait){\r\n\t\t\t\tvar THROTTLE = 5000,\r\n\t\t\t\t\tstarted = Date.now(),\r\n\t\t\t\t\tstore = this;\r\n\t\t\t\t\r\n\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\tif ((method === 'GET') && data) {\r\n\t\t\t\t\t\tvar hashIdx = url.indexOf('#'),   \r\n\t\t\t\t\t\t\thash = hashIdx !== -1 ? url.substring(hashIdx) : '',\r\n\t\t\t\t\t\t\tqsIdx = url.indexOf('?'),\r\n\t\t\t\t\t\t\tqs = qsIdx !== -1 ? url.substring(qsIdx) : '';\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (data.criteria) {\r\n\t\t\t\t\t\t\tfor (var key in data.criteria) {\r\n\t\t\t\t\t\t\t\tif (data.criteria.hasOwnProperty(key)) {\r\n\t\t\t\t\t\t\t\t\tqs += (qs ? '&' : '') + encodeURIComponent(key) + '=' \r\n\t\t\t\t\t\t\t\t\t\t\t+ encodeURIComponent(data.criteria[key].toString());\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (data.pageSize) {\r\n\t\t\t\t\t\t\tqs += (qs ? '&' : '') + 'pg=' + data.pageIndex + '&pgsz=' + data.pageSize;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\turl = url + qs + hash;\r\n\t\t\t\t\t\tdata = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t\trequest(method, url, data, error, resolve, reject);\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tfunction info(data) {\r\n\t\t\t\t\tvar info = '';\r\n\t\t\t\t\tif (data) {\r\n\t\t\t\t\t\tif (data.length) {info = '(' + data.length + ' items)';}\r\n\t\t\t\t\t\telse if (data.createdItems) {\r\n\t\t\t\t\t\t\tvar parts = [];\r\n\t\t\t\t\t\t\tif (data.createdItems.length) {parts.push(data.createdItems.length + ' created');} \r\n\t\t\t\t\t\t\tif (data.updatedItems.length) {parts.push(data.updatedItems.length + ' updated');}\r\n\t\t\t\t\t\t\tif (data.deletedItems && data.deletedItems.length) {parts.push(data.deletedItems.length + ' deleted');}\r\n\t\t\t\t\t\t\tif (data.deletedIds && data.deletedIds.length) {parts.push(data.deletedIds.length + ' deleted');}\r\n\t\t\t\t\t\t\tif (parts.length) {info = '(' + parts.join(', ') + ')';}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn info;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfunction request(method, url, data, errorHandler, resolve, reject) {\r\n\t\t\t\t\tvar pre = '';\r\n\t\t\t\t\tfor (var i=0; i<6-method.length; i++) {pre += ' ';}\r\n\t\t\t\t\tlog().log(' -> ' + pre + method + ' ' + url + ' ' + info(data));\r\n\t\t\t\t\t\r\n\t\t\t\t\t$.ajax(url, {\r\n\t\t\t\t\t\tmethod: method,\r\n\t\t\t\t\t\tcontentType: 'application/json',\r\n\t\t\t\t\t\tprocessData: false,\r\n\t\t\t\t\t\tdata: data && JSON.stringify(data),\r\n\t\t\t\t\t\ttimeout: timeout\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.done(function(data, statusText, jqXHR){\r\n\t\t\t\t\t\tif (jqXHR.responseText.indexOf('j_security_check') !== -1) {\r\n\t\t\t\t\t\t\t// login challenge from server, session expired\r\n\t\t\t\t\t\t\tlog().info('401 ' + pre + method + ' ' + url + ' ' + info(data) + ' (LOGIN CHALLENGE)');\r\n\t\t\t\t\t\t\terrorHandler(jqXHR, method, url, data, resolve, reject);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tlog().info('200 ' + pre + method + ' ' + url + ' ' + info(data) + ' (OK)');\r\n\t\t\t\t\t\t\tretries = 0;\r\n\t\t\t\t\t\t\tresolve(Persistent.fromJSON(jqXHR.responseText));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.fail(function(jqXHR, textStatus, errorThrown) {\r\n\t\t\t\t\t\tjqXHR.statusText = errorThrown || textStatus; \r\n\t\t\t\t\t\tlog().warn(jqXHR.status + ' ' + pre + method + ' ' + url + ' ' + info(data) + ' (' + jqXHR.statusText + ')');\r\n\t\t\t\t\t\terrorHandler(jqXHR, method, url, data, resolve, reject);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfunction error(jqXHR, method, url, data, resolve, reject) {\r\n\t\t\t\t\t// status code 5xx ? possibly recoverable.\r\n\t\t\t\t\tvar statusText = jqXHR.statusText;\r\n\t\t\t\t\tswitch(status) {\r\n\t\t\t\t\t\tcase 500: // Internal server error\r\n\t\t\t\t\t\tcase 502: // Bad Gateway\r\n\t\t\t\t\t\tcase 503: // Service unavailable\r\n\t\t\t\t\t\tcase 504: // Gateway Timeout\r\n\t\t\t\t\t\t\tif (retries > 0) {\r\n\t\t\t\t\t\t\t\tretry(jqXHR, method, url, data, errorHandler, resolve, reject);\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tcase 200: // Happens in case of server login challenge when unauthorized\r\n\t\t\t\t\t\t\tif (jqXHR.status == 200) {\r\n\t\t\t\t\t\t\t\t// TODO handle this\r\n\t\t\t\t\t\t\t\tstatusText = 'Session expired.';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdefault: // unrecoverable or too many tries. give up \r\n\t\t\t\t\t\t\tretries = 0;\r\n\t\t\t\t\t\t\tvar err = new Error(jqXHR.status + ' ' + statusText);\r\n\t\t\t\t\t\t\terr.status = jqXHR.status;\r\n\t\t\t\t\t\t\terr.statusText = statusText;\r\n\t\t\t\t\t\t\terr.request = jqXHR;\r\n\t\t\t\t\t\t\terr.method = method;\r\n\t\t\t\t\t\t\terr.url = url;\r\n\t\t\t\t\t\t\terr.data = data;\r\n\t\t\t\t\t\t\treject(err);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfunction retry(jqXHR, method, url, data, errorHandler, resolve, reject) {\r\n\t\t\t\t\tretries--;\r\n\t\t\t\t\tvar after = 3000; // 5 minutes\r\n\t\t\t\t\tvar retryAfter = jqXHR.getResponseHeader('Retry-After');\r\n\t\t\t\t\tif (retryAfter) {\r\n\t\t\t\t\t\tvar tmp = parseInt(retryAfter, 10);\r\n\t\t\t\t\t\tif (! isNaN(tmp)) {\r\n\t\t\t\t\t\t\tafter = tmp * 1000; // seconds to ms.\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tsetTimeout(function(){\r\n\t\t\t\t\t\trequest(method, url, data, errorhandler, resolve, reject);\r\n\t\t\t\t\t}, after);\r\n\t\t\t\t}\r\n\t\t\t})(method, url, data, this.cfg.timeout, this.cfg.retryCount, this.cfg.retryWaitTime);\r\n\t\t}\r\n\t});\r\n\r\n\tfunction RestDataStoreFactory(name, url, cfg) {\r\n\t\treturn new RestDataStore(name, url, cfg);\r\n\t}\r\n\t\r\n\tDataStore.registerType('http', RestDataStoreFactory);\r\n\tDataStore.registerType('https', RestDataStoreFactory);\r\n\r\n\treturn RestDataStore;\r\n});\r\n\n","define('bridalapp/brands',['lang/class', 'jquery', 'bridalapp/syncheddatastore', 'bridalapp/rhaboodatastore', 'bridalapp/restdatastore'], function (Class, $, SynchedDataStore) {\r\n\tvar Brands = Class('Brands', SynchedDataStore, {\r\n\t\tinitialize: function Brands_initialize($super) {\r\n\t\t\t$super('brands', 'synched://rhaboo/bridal-app/brands#http/api/brands');\r\n\t\t}\r\n\t});\r\n\r\n\treturn new Brands();\r\n});\r\n\n","define('bridalapp/category',['lang/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Category = Class('Category', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t}\r\n\t});\r\n\r\n\treturn Category;\r\n});\n","define('bridalapp/credential',['lang/class', 'bridalapp/persistent'], function(Class, Persistent){\r\n\tvar Credential = Class('Credential', Persistent, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn Credential;\r\n});\n","define('bridalapp/group',['lang/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Group = Class('Group', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.description = (obj && obj.description) || null;\r\n\t\t}\r\n\t});\r\n\r\n\treturn Group;\r\n});\n","define('bridalapp/password-credential',['lang/class', 'bridalapp/credential'], function(Class, Credential){\r\n\tvar PasswordCredential = Class('PasswordCredential', Credential, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.password = (obj && obj.password) || null;\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn PasswordCredential;\r\n});\n","define('bridalapp/product',['lang/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Product = Class('Product', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.description = (obj && obj.description) || null;\r\n\t\t\tthis.priceWholesaleEuroCent = (obj && obj.priceWholesaleEuroCent) || null;\r\n\t\t\tthis.priceConsumerEuroCent = (obj && obj.priceConsumerEuroCent) || null;\r\n\t\t\tthis.brandId = (obj && obj.brandId) || null;\r\n\t\t\tthis.brandName = (obj && obj.brandName) || null;\r\n\t\t\tthis.categoryId = (obj && obj.categoryId) || null;\r\n\t\t\tthis.categoryName = (obj && obj.categoryName) || null;\r\n\t\t\tthis.tags = (obj && obj.tags) || null;\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn Product;\r\n});\n","define('bridalapp/products',['lang/class', 'jquery', 'bridalapp/syncheddatastore', 'bridalapp/rhaboodatastore', 'bridalapp/restdatastore'], function (Class, $, SynchedDataStore) {\r\n\tvar Products = Class('Products', SynchedDataStore, {\r\n\t\tinitialize: function Products_initialize($super) {\r\n\t\t\t$super('products', 'synched://rhaboo/bridal-app/products#http/api/products');\r\n\t\t\tthis.cfg.remoteDataStore.cfg.supportsSynch = true;\r\n\t\t}\r\n\t});\r\n\r\n\treturn new Products();\r\n});\r\n\n","define('bridalapp/rating',['lang/class', 'bridalapp/persistent'], function(Class, Persistent){\r\n\tvar Rating = Class('Rating', Persistent, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.productId = (obj && obj.productId) || null;\r\n\t\t\tthis.accountId = (obj && obj.accountId) || null;\r\n\t\t\tthis.score = (obj && obj.score) || null;\r\n\t\t}\r\n\t});\r\n\r\n\treturn Rating;\r\n});\n","define('bridalapp/ratings',['lang/class', 'jquery', 'bridalapp/syncheddatastore', 'bridalapp/rhaboodatastore', 'bridalapp/restdatastore'], function (Class, $, SynchedDataStore) {\r\n\tvar Ratings = Class('Ratings', SynchedDataStore, {\r\n\t\tinitialize: function Ratings_initialize($super) {\r\n\t\t\t$super('ratings', 'synched://rhaboo/bridal-app/ratings#http/api/ratings');\r\n\t\t\tthis.cfg.remoteDataStore.cfg.supportsSynch = true;\r\n\t\t}\r\n\t});\r\n\r\n\treturn new Ratings();\r\n});\r\n\n","define('bridalapp/role',['lang/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Role = Class('Role', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t}\r\n\t});\r\n\r\n\treturn Role;\r\n});\n","/**!\r\n * @copyright (c) 2015 by Stijn de Witt. Some rights reserved.\r\n * @license <a href=\"https://creativecommons.org/licenses/by/4.0/\">Attribution 4.0 International (CC BY 4.0)</a> \r\n */\r\ndefine('bridalapp',[\r\n\t\t// Pull in all classes\r\n\t\t'bridalapp/account', \r\n\t\t'bridalapp/brand',\r\n\t\t'bridalapp/brands',\r\n\t\t'bridalapp/category',\r\n\t\t'bridalapp/credential',\r\n\t\t'bridalapp/group',\r\n\t\t'bridalapp/log', \r\n\t\t'bridalapp/named',\r\n\t\t'bridalapp/password-credential', \r\n\t\t'bridalapp/persistent',\r\n\t\t'bridalapp/product',\r\n\t\t'bridalapp/products',\r\n\t\t'bridalapp/rating',\r\n\t\t'bridalapp/ratings',\r\n\t\t'bridalapp/role'\r\n\t], \r\n\t\r\n\tfunction(\r\n\t\tAccount, \r\n\t\tBrand,\r\n\t\tBrands,\r\n\t\tCategory,\r\n\t\tCredential,\r\n\t\tGroup,\r\n\t\tlog,\r\n\t\tNamed,\r\n\t\tPasswordCredential, \r\n\t\tPersistent,\r\n\t\tProduct,\r\n\t\tProducts,\r\n\t\tRating,\r\n\t\tRatings,\r\n\t\tRole\r\n\t){\r\n\t\t// Create a namespace with all classes in it and return it\r\n\t\treturn {\r\n\t\t\tAccount: Account, \r\n\t\t\tBrand: Brand,\r\n\t\t\tBrands: Brands,\r\n\t\t\tCategory: Category,\r\n\t\t\tCredential: Credential,\r\n\t\t\tGroup: Group,\r\n\t\t\tlog: log,\r\n\t\t\tNamed: Named,\r\n\t\t\tPasswordCredential: PasswordCredential, \r\n\t\t\tPersistent: Persistent,\r\n\t\t\tProduct: Product,\r\n\t\t\tProducts: Products,\r\n\t\t\tRating: Rating,\r\n\t\t\tRatings: Ratings,\r\n\t\t\tRole: Role,\r\n\t\t\t\r\n\t\t\tglobalize: function(global){\r\n\t\t\t\tfor (var key in this) {\r\n\t\t\t\t\tif (this.hasOwnProperty(key)) {\r\n\t\t\t\t\t\tglobal[key] = this[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n);\n"]}