{"version":3,"file":"bridalapp.min.js","sources":["bridalapp/class.js","bridalapp/datastore.js","bridalapp/synchabledatastore.js","bridalapp/persistent.js","bridalapp/rhaboodatastore.js","bridalapp/log.js","bridalapp/restdatastore.js","bridalapp/named.js","bridalapp/account.js","bridalapp/brand.js","bridalapp/synchrequest.js","bridalapp/synchresponse.js","bridalapp/syncheddatastore.js","bridalapp/brands.js","bridalapp/category.js","bridalapp/credential.js","bridalapp/group.js","bridalapp/password-credential.js","bridalapp/product.js","bridalapp/products.js","bridalapp/rating.js","bridalapp/ratings.js","bridalapp/role.js","bridalapp.js"],"names":["define","Class","name","parent","args","arrayify","arguments","String","shift","classname","eval","klass","superclass","subclasses","subclass","prototype","push","i","len","length","addMethods","initialize","constructor","argumentNames","fn","names","toString","match","split","replace","it","Object","toArray","results","Array","bind","func","undefined","obj","splice","apply","concat","wrap","wrapper","this","src","keys","key","ancestor","props","val","argNames","method","m","valueOf","sub","subsub","DataStore","url","cfg","listeners","throttle","on","event","listener","trigger","me","triggered","Date","now","timeout","clearTimeout","setTimeout","call","off","load","Promise","resolve","count","save","item","delete","typeFactories","registerType","type","factory","fromType","fromUrl","idx","indexOf","s","substring","Suid","SynchableDataStore","$super","get","criteria","pageSize","pageIndex","clone","items","Persistent","page","matches","looksSynched","lastSynched","getTime","createdItems","updatedItems","deletedItems","synch","isSynching","newDate","staleItems","failedItems","futureItems","set","del","id","version","equals","other","value","revive","t","fromJSON","json","JSON","parse","persistent","arg","j","one","comparator","list","element","hasOwnProperty","isArray","pluck","attr","stringify","start","end","slice","Math","max","min","eachArg","RhabooDataStore","rhaboo","store","repoIdx","storeIdx","lastIndexOf","repo","backup","db","deleted","updated","synching","future","removed","date","write","stale","failed","Rhaboo","log","out","METHODS","console","error","con","nul","level","lvl","logLevel","DEBUG","INFO","WARN","ERROR","NONE","$","RestDataStoreFactory","RestDataStore","retryCount","retryWaitTime","supportsSynch","remoteRequest","reject","then","e","all","synchRequest","data","retries","info","parts","deletedIds","join","request","errorHandler","pre","ajax","contentType","processData","done","statusText","jqXHR","responseText","fail","textStatus","errorThrown","warn","status","retry","err","Error","after","retryAfter","getResponseHeader","tmp","parseInt","isNaN","errorhandler","hashIdx","hash","qsIdx","qs","encodeURIComponent","Named","Account","roles","groups","credentials","Brand","SynchRequest","unsynchedDuration","synchDuration","currentIds","currentVersions","SynchResponse","handleLoadedItems","old","changed","staleIdx","handleSavedItems","merged","handleDeletedItems","poorMansSynch","pollInterval","remoteDataStore","dirty","synchError","autoSynch","autoSynchActive","setInterval","synchInterval","SynchedDataStore","remoteSynch","localDataStore","urls","localParts","localType","localRepo","localStore","remoteParts","remoteType","remoteRepo","remoteStore","force","req","filter","response","Brands","Category","Credential","Group","description","PasswordCredential","password","Product","priceWholesaleEuroCent","priceConsumerEuroCent","brandId","brandName","categoryId","categoryName","tags","Products","Rating","productId","accountId","score","Ratings","Role","globalize","global"],"mappings":"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","sourcesContent":["define('bridalapp/class',[], function(){\r\n\t/**\r\n\t * Class([name] [, parent], object [, object] [, object])\r\n\t *\r\n\t * Creates a new class with the given name, parent and methods.\r\n\t *\r\n\t * name    String, Optional. The name of the new class. \r\n\t *         If not specified the new class will be anonymous.\r\n\t * parent  Class object, optional. The parent class for the new class.\r\n\t * object  Object, Required. One or more objects containing the methods \r\n\t *         and fields to add to the new class.\r\n\t */\r\n\tfunction Class() {\r\n\t\tvar name = '', parent = null, args = arrayify(arguments);\r\n\t\tif (typeof args[0] === 'string' || args[0] instanceof String) {\r\n\t\t\tname = args.shift();\r\n\t\t}\r\n\t\tif (typeof args[0] === 'function') {\r\n\t\t\tparent = args.shift();\r\n\t\t}\r\n\t\tvar classname = name || 'klass';\r\n\t\teval('var klass = function ' + classname + '() {this.initialize.apply(this, arguments);}'); // jshint ignore:line\r\n\t\tklass.classname = classname;\r\n\t\tklass.superclass = parent;\r\n\t\tklass.subclasses = [];\r\n\r\n\t\tif (parent) {\r\n\t\t\tvar subclass = function() { };\r\n\t\t\tsubclass.prototype = parent.prototype;\r\n\t\t\tklass.prototype = new subclass();\r\n\t\t\tparent.subclasses.push(klass);\r\n\t\t}\r\n\r\n\t\tfor (var i=0, len=args.length; i<len; i++) {\r\n\t\t\taddMethods(klass, args[i]);\r\n\t\t}\r\n\t\tif (!klass.prototype.initialize) {\r\n\t\t\tklass.prototype.initialize = function() { };\r\n\t\t}\r\n\t\tklass.prototype.constructor = klass;\r\n\t\treturn klass;\r\n\t}\r\n\r\n\tClass.subclass = function Class_subclass(klass, name) {\r\n\t\tif (!klass) {return;}\r\n\t\tif (klass.classname === name) {return klass;}\r\n\t\tfor (var i=0, sub; sub=klass.subclasses[i]; i++) {\r\n\t\t\tif (sub.classname === name) {return sub;}\r\n\t\t\tvar subsub = Class.subclass(sub, name);\r\n\t\t\tif (subsub) {return subsub;}\r\n\t\t}\r\n\t};\r\n\r\n\tfunction argumentNames(fn) {\r\n\t\tvar i, len, names = fn.toString().match(/^[\\s\\(]*function[^(]*\\((.*?)\\)/)[1].split(',');\r\n\t\tfor (i=0, len=names.length; i<len; i++) {\r\n\t\t\tnames[i] = names[i].replace(/^\\s+/, '').replace(/\\s+$/, '');\r\n\t\t}\r\n\t\treturn len === 1 && !names[0] ? [] : names;\r\n\t}\r\n\r\n\tfunction arrayify(it) {\r\n\t\tif (!it) {return [];}\r\n\t\tif ('toArray' in Object(it)) {return it.toArray();}\r\n\t\tvar len = it.length || 0, results = new Array(len);\r\n\t\twhile (len--) {results[len] = it[len];}\r\n\t\treturn results;\r\n\t}\r\n\r\n\tfunction bind(func) {\r\n\t\tif (arguments.length < 3 && arguments[1] === undefined) {return func;}\r\n\t\tvar args = arrayify(arguments), obj = args.splice(0, 2)[1];\r\n\t\treturn function() {\r\n\t\t\treturn func.apply(obj, args.concat(arrayify(arguments)));\r\n\t\t};\r\n\t}\r\n\r\n\tfunction wrap(func, wrapper) {\r\n\t\treturn function() {\r\n\t\t\treturn wrapper.apply(this, [bind(func, this)].concat(arrayify(arguments)));\r\n\t\t};\r\n\t}\r\n\r\n\tfunction addMethods(klass, src) {\r\n\t\tfunction keys(obj) {\r\n\t\t\tvar results = [];\r\n\t\t\tfor (var key in obj) {\r\n\t\t\t\tresults.push(key);\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t}\r\n\r\n\t\tvar ancestor = klass.superclass && klass.superclass.prototype, props = keys(src);\r\n\r\n\t\tfor (var i=0, key; key=props[i]; i++) {\r\n\t\t\tvar val = src[key];\r\n\t\t\tif (ancestor && (typeof val === 'function')) {\r\n\t\t\t\tvar argNames = argumentNames(val);\r\n\t\t\t\tif ((argNames.length > 0) && (argNames[0] === '$super')) {\r\n\t\t\t\t\tvar method = val;\r\n\t\t\t\t\tval = wrap((function(m) {\r\n\t\t\t\t\t\treturn function() {\r\n\t\t\t\t\t\t\treturn ancestor[m].apply(this, arguments); \r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t})(key), method); // jshint ignore:line\r\n\t\t\t\t\tval.valueOf = bind(method.valueOf, method);\r\n\t\t\t\t\tval.toString = bind(method.toString, method);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tklass.prototype[key] = val;\r\n\t\t}\r\n\t}\r\n\r\n\treturn Class;\r\n});\r\n\n","define('bridalapp/datastore',['bridalapp/class'], function (Class) {\r\n\t'use strict';\r\n\t\r\n\t/**\r\n\t * 'Abstract' base class for datastores.\r\n\t * \r\n\t * <p>Interaction with the datastore happens through four methods:</p>\r\n\t * <dl>\r\n\t *   <dt><code>Promise <b>load</b>(criteria, pageSize, pageIndex)</code></dt>\r\n\t *   <dd>Loads items from the store that match the given <code>criteria</code> (if any), \r\n\t *       paging the results if so desired.</dd>\r\n\t *   <dt><code>Promise <b>count</b>(criteria)</code></dt>\r\n\t *   <dd>Counts the items that match the given <code>criteria</code> (if any). This count\r\n\t *       can be used to calculate the <code>pageIndex</code> parameters when using paging.</dd>\r\n\t *   <dt><code>Promise <b>save</b>(items)</code></dt>\r\n\t *   <dd>Adds new items to the store, or updates existing items.</dd>\r\n\t *   <dt><code>Promise <b>delete</b>(items)</code></dt>\r\n\t *   <dd>Permanently deletes items from the store.</dd>\r\n\t * </ul>\r\n\t * <p>All three methods return a <code>Promise</code> that resolves to an \r\n\t * 'immutable' array(-like) with the fetched, changed or deleted items in it.</p>\r\n\t * \r\n\t * <p>Furthermore, the store can be observed for changes by attaching a listener\r\n\t * to the <code>change</code> event using the <code>on</code> method:</p>\r\n\t * <code><pre>\r\n\t * myDataStore.on('change', function() {\r\n\t *   // The store has changed. \r\n\t * });\r\n\t * </pre></code>\r\n\t * <p>The listener(s) can be removed again using the <code>off</code> method:</p>\r\n\t * <code><pre>\r\n\t * myDataStore.off('change', myListener); // removes myListener from change event\r\n\t * myDataStore.off('change'); // removes all listeners from change event\r\n\t * </pre></code>\r\n\t * \r\n\t */\r\n\tvar DataStore = Class('DataStore', {\r\n\t\t\r\n\t\tinitialize: function DataStore_initialize(name, url, cfg) {\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.url = url || ''; // storetype://path/to/repository/store\r\n\t\t\tthis.cfg = cfg || {};\r\n\t\t\tthis.cfg.listeners = this.cfg.listeners || {};\r\n\t\t\tthis.cfg.throttle = this.cfg.throttle || {};\r\n\t\t},\r\n\t\t\r\n\t\ton: function DataStore_on(event, listener) {\r\n\t\t\tthis.cfg.listeners[event] = this.cfg.listeners[event] || [];\r\n\t\t\tthis.cfg.listeners[event].push(listener);\r\n\t\t},\r\n\r\n\t\ttrigger: function DataStore_trigger(event) {\r\n\t\t\tvar me = this, cfg = me.cfg, listeners = cfg.listeners[event];\r\n\t\t\tif (listeners) {\r\n\t\t\t\tif (! cfg.throttle[event]) {\r\n\t\t\t\t\tcfg.throttle[event] = {\r\n\t\t\t\t\t\ttriggered: Date.now()\r\n\t\t\t\t\t};\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tvar throttle = cfg.throttle[event];\r\n\t\t\t\tif (throttle.timeout &&\t(Date.now() < throttle.triggered + 250)) {\r\n\t\t\t\t\tclearTimeout(throttle.timeout);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthrottle.triggered = Date.now();\r\n\t\t\t\t}\r\n\t\t\t\tthrottle.timeout = setTimeout(function(){\r\n\t\t\t\t\tfor (var i=0,listener; listener=listeners[i]; i++) {\r\n\t\t\t\t\t\tlistener.call(me);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthrottle.timeout = null;\r\n\t\t\t\t}, 10);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\toff: function DataStore_off(event, listener) {\r\n\t\t\tif (this.cfg.listeners[event]) {\r\n\t\t\t\tif (listener) {\r\n\t\t\t\t\tfor (var i=this.cfg.listeners[event].length-1; i>=0; i--) {\r\n\t\t\t\t\t\tif (this.cfg.listeners[event][i] === listener) {\r\n\t\t\t\t\t\t\treturn this.cfg.listeners[event].splice(i, 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar results = this.cfg.listeners[event];\r\n\t\t\t\t\tdelete this.cfg.listeners[event];\r\n\t\t\t\t\treturn results;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n//      ABSTRACT-------------------------------------------------------------------------------------------\r\n//\t\t                    'abstract' methods each datastore should have.\r\n//      ---------------------------------------------------------------------------------------------------\r\n\r\n\t\t/**\r\n\t\t * Loads all items from this store matching the given <code>criteria</code>.\r\n\t\t * \r\n\t\t * <p>This method returns a <code>Promise</code> that resolves to an array(-like) that should be\r\n\t\t * treated as immutable. To mutate the store, use <code>save</code> and <code>delete</code>.</p>\r\n\t\t * \r\n\t\t * @param criteria Criteria to match on. Optional. Object.\r\n\t\t * @param pageSize Limits the number of results to fetch. Optional. Number.\r\n\t\t * @param pageIndex Indicates which results to fetch. Optional. Only applies when \r\n\t\t *        <code>pageSize &gt; 0</code>. Number. \r\n\t\t * \r\n\t\t * @return A <code>Promise<code> that resolves to an 'immutable' array of items, \r\n\t\t *         possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tload: function DataStore_load(criteria, pageSize, pageIndex) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve([]);\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Counts the items matching the given <code>criteria</code>.\r\n\t\t * \r\n\t\t * <p>This method returns a <code>Promise</code> that resolves to the number of items that match\r\n\t\t * the given <code>criteria</code>, or to the total number of items if no <code>criteria</code> \r\n\t\t * were given. Using this number (which will be typically obtained with an efficient operation\r\n\t\t * such as <code>SELECT COUNT(..)</code>) you can calculate the number of pages for a certain\r\n\t\t * <code>pageSize</code> and thus determine the valid range for the <code>pageIndex</code>\r\n\t\t * parameter of the <code>load</code> operation.</p>\r\n\t\t * \r\n\t\t * @param criteria Criteria to match on. Optional. Object.\r\n\t\t * \r\n\t\t * @return A <code>Promise<code> that resolves to an 'immutable' array of items, \r\n\t\t *         possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tcount: function DataStore_count(criteria) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(0);\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Saves the given <code>item</code>(s).\r\n\t\t * \r\n\t\t * <p>Returns a <code>Promise</code> that resolves to an 'immutable' array(-like) with the added \r\n\t\t * or changed items. These items may have changes compared with the given items (such as last \r\n\t\t * modified date, version etc) so the originals are stale after this method completes.</p> \r\n\t\t * \r\n\t\t * <p>The argument can be an instance of <code>Persistent</code> or an array(-like) of instances \r\n\t\t * of <code>Persistent.</code>. Multiple arguments can be given. These are all ways to save \r\n\t\t * three persistent objects <code>a</code>, <code>b</code> and <code>c</code>:</p>\r\n\t\t * \r\n\t\t * <code><pre>\r\n\t\t * myDataStore.save(a);\r\n\t\t * myDataStore.save(b);\r\n\t\t * myDataStore.save(c);\r\n\t\t * // or\r\n\t\t * myDataStore.save(a, b, c);\r\n\t\t * // or\r\n\t\t * myDataStore.save([a,b,c]);\r\n\t\t * // or\r\n\t\t * myDataStore.save(a, [b,c]);\r\n\t\t * // etc...\r\n\t\t * </pre></code>\r\n\t\t * \r\n\t\t * <p>If we need to wait for the result of the operation, we can do so like this:</p>\r\n\t\t * \r\n\t\t * <code><pre>\r\n\t\t * myDataStore.save(myItems).then(function(results){\r\n\t\t *    // Hooray! The items are saved!\r\n\t\t *    for (var i=0, item; item=results[i]; i++) { \r\n\t\t *       // do something kick-ass with this item\r\n\t\t *       alert('Yeah! ' + item + ' is saved!'); \r\n\t\t *    }\r\n\t\t * }).catch(function(e){\r\n\t\t *    // Oh no!! Something went wrong!\r\n\t\t *    alert('There was an error: ' + e);\r\n\t\t * });\r\n\t\t * </pre></code>\r\n\t\t * \r\n\t\t * \r\n\t\t * @param  item Either a single persistent item or an array(-like) of persistent items. \r\n\t\t * @return A <code>Promise</code> that resolves to an 'immutable' array of items that were added \r\n\t\t *         or changed. Possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tsave: function DataStore_save(item) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(item.length === undefined ? [item] : item);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Permanently deletes the given <code>item</code>s.\r\n\t\t * \r\n\t\t * <p>Returns a <code>Promise</code> that yields the removed items in an array(-like). \r\n\t\t * The returned array(-like) should be treated as immutable.</p>\r\n\t\t * \r\n\t\t * <p>The argument can be an instance of Persistent or an array(-like) of instances of Persistent. \r\n\t\t * Just like with <code>save()</code>, multiple arguments can be given.</p>\r\n\t\t * \r\n\t\t * @param  item Either a single persistent item or an array(-like) of persistent items. \r\n\t\t * @return An 'immutable' array of items that were removed. Possibly empty but never <code>null</code>.\r\n\t\t */\r\n\t\tdelete: function DataStore_delete(item) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve('length' in item ? item : [item]);\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n//      /ABSTRACT------------------------------------------------------------------------------------------\r\n\t\t\r\n\t\ttoString: function DataStore_toString() {\r\n\t\t\treturn '[Object ' + this.constructor.classname + ' \\'' + this.name + '\\' {url: \\'' + this.url + '\\'}]';\r\n\t\t}\r\n\t});\r\n\r\n\t/** Registry of datastore factories by type. */\r\n\tDataStore.typeFactories = {};\r\n\t\r\n\t/** Registers the datastore <code>factory</code> as 'protocol handler' for the given <code>type</code>. */\r\n\tDataStore.registerType = function DataStore_registerType(type, factory) {\r\n\t\tif (! DataStore.typeFactories[type]) {\r\n\t\t\tDataStore.typeFactories[type] = factory;\r\n\t\t}\r\n\t};\r\n\t\r\n\t/** Creates a new datastore from the given <code>type</code>. */\r\n\tDataStore.fromType = function DataStore_fromType(name, type, url, cfg) {\r\n\t\treturn DataStore.typeFactories[type](name, url, cfg);\r\n\t};\r\n\t\r\n\t/** Creates a new datastore from the given <code>url</code>. */\r\n\tDataStore.fromUrl = function DataStore_fromUrl(name, url, cfg) {\r\n\t\tif (! url) {return null;}\r\n\t\tvar idx = url.indexOf('://'),\r\n\t\t\ts = url.substring(0, idx), \r\n\t\t\ttype = s === 'https' ? 'http' : (s || 'http');\r\n\t\treturn DataStore.fromType(name, type, url, cfg);\r\n\t};\r\n\t\r\n\treturn DataStore;\r\n});\r\n\n","define('bridalapp/synchabledatastore',['suid', 'bridalapp/class', 'bridalapp/datastore'], function (Suid, Class, DataStore) {\r\n\t'use strict';\r\n\t\r\n\t/**\r\n\t * 'Abstract' base class for local datastores that can synched with some backend.\r\n\t * \r\n\t * <p>The main API of synchable datastores is:</p>\r\n\t * \r\n\t * <dl>\r\n\t *   <dt><code>Boolean <b>lookSynched</b>()</code></dt>\r\n\t *   <dd>Indicates whether the datastore looks synched (from this end).</dd>\r\n\t *   <dt><code>Promise <b>synch</b>()</code></dt>\r\n\t *   <dd>Brings this datastore back into synch.</dd>\r\n\t *   <dt><code>Boolean <b>isSynching</b>()</code></dt>\r\n\t *   <dd>Indicates whether this datastore is currently busy synching.</dd>\r\n\t *   <dt><code>Array(-like) <b>items</b>()</code></dt>\r\n\t *   <dd>Returns an 'immutable' array(-like) that represents a live view of the items \r\n\t *       maintained in this store.</dd>\r\n\t *   <dt><code>Array <b>createdItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that have been added to the store since the last synch.</dd>\r\n\t *   <dt><code>Array <b>updatedItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that have been updated since the last synch.</dd>\r\n\t *   <dt><code>Array <b>deletedItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that have been deleted from the store since the last synch.</dd>\r\n\t *   <dt><code>Array <b>staleItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that could not be saved during the last synch because they went stale.</dd>\r\n\t *   <dt><code>Array <b>failedItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that could not be saved during the last synch because they had errors.</dd>\r\n\t *   <dt><code>Array <b>futureItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that were already updated when a synch started and were then updated again while synch was in progress.</dd>\r\n\t * </dl>\r\n\t * \r\n\t * <p>synchable datastores are assumed to have fast access to (a cache of) all data they maintain.\r\n\t * As such they provide a synchronous API for accessing and mutating the data in the datastore \r\n\t * that is easier to work with than the default asynchronous <code>load</code>, <code>count</code>, \r\n\t * <code>save</code> and <code>delete</code> methods:</p>\r\n\t * \r\n\t * <dl>\r\n\t *   <dt><code>Array get(criteria, pageSize, pageIndex)</code></dt>\r\n\t *   <dd>Synchronous equivalent of <code>load</code>.</dd>\r\n\t *   <dt><code>Number len(criteria)</code></dt>\r\n\t *   <dd>Synchronous equivalent of <code>count</code>.</dd>\r\n\t *   <dt><code>Array set(item)</code></dt>\r\n\t *   <dd>Synchronous equivalent of <code>save</code>.</dd>\r\n\t *   <dt><code>Array del(item)</code></dt>\r\n\t *   <dd>Synchronous equivalent of <code>delete</code>.</dd>\r\n\t * </dl>\r\n\t * \r\n\t * <p>The synchronous methods operate on the locally cached data. As such, the\r\n\t * methods <code>set</code> and <code>del</code> will usually make the datastore\r\n\t * <i>out of synch</i>. You can check whether the datastore still looks in synch\r\n\t * with <code>looksSynched</code> and bring it back in synch with <code>synch</code>.</p>\r\n\t * \r\n\t * <p>Unlike their asynchonous counterparts, the synchronous methods <code>set</code>\r\n\t * and <code>del</code> return the items unchanged, so essentially they can be\r\n\t * discarded.</p>\r\n\t */\r\n\tvar SynchableDataStore = Class('SynchableDataStore', DataStore, {\r\n\t\t\r\n\t\tinitialize: function SynchableDataStore_initialize($super, name, url, cfg) {\r\n\t\t\t$super(name, url, cfg);\r\n\t\t},\r\n\t\t\r\n\t\t/** \r\n\t\t * Synchronous equivalent of <code>load</code>.\r\n\t\t * \r\n\t\t * <p>No remote request will actually be fired. The filtering based on the\r\n\t\t * given <code>criteria</code> and the paging both happen client-side and\r\n\t\t * will be fast as long as the dataset is not too large.</p>\r\n\t\t */\r\n\t\tget: function SynchableDataStore_get(criteria, pageSize, pageIndex, clone) {\r\n\t\t\tvar items = clone ? Persistent.clone(this.items()) : this.items();\r\n\t\t\treturn Persistent.page(Persistent.matches(items, criteria), pageSize, pageIndex);\r\n\t\t},\r\n\r\n\t\t/** \r\n\t\t * Synchronous equivalent of <code>count</code>.\r\n\t\t *  \r\n\t\t * <p>No remote request will actually be fired. This method just calls\r\n\t\t * <code>get</code> with the given <code>criteria</code> and returns\r\n\t\t * the number of results it got.</p>\r\n\t\t */\r\n\t\tlen: function SynchableDataStore_len(criteria) {\r\n\t\t\treturn this.get(criteria).length;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Indicates whether this datastore looks synchronized (from this end). \r\n\t\t * \r\n\t\t * <p>This method will return <code>false</code> if there are any outstanding changes, \r\n\t\t * but this method returning <code>true</code> does not guarantee anything as it is \r\n\t\t * impossible to determine whether something was changed on the remote side without\r\n\t\t * actually making a request.\r\n\t\t */\r\n\t\tlooksSynched: function SynchableDataStore_looksSynched() {\r\n\t\t\t// if lastSynched == Date(0) (epoch) it means we are not synched\r\n\t\t\t// if there are any items in any of the lists it means we are not in synch\r\n\t\t\treturn (this.lastSynched().getTime() !== 0) && \r\n\t\t\t\t\t(! (this.createdItems().length || this.updatedItems().length || this.deletedItems().length));\r\n\t\t},\r\n\t\t\r\n\r\n//\t\tABSTRACT-------------------------------------------------------------------------\r\n//\t\t             'abstract' methods each synchable datastore should have\r\n//\t\t---------------------------------------------------------------------------------\r\n\t\t/** \r\n\t\t * Brings this datastore back into synch.\r\n\t\t * \r\n\t\t * <p>Returns a promise that resolves on synch complete or rejects on\r\n\t\t * synch failure. The arrays returned by <code>staleItems</code> and \r\n\t\t * <code>failedItems</code> will be updated with items that could not\r\n\t\t * be saved because they had been changed on the remote server in the\r\n\t\t * meantime, or that gave (integrity constraint) validation errors,\r\n\t\t * respectively.</p> \r\n\t\t */\r\n\t\tsynch: function SynchableDataStore_synch() {return new Promise(function(resolve){resolve();})},\r\n\r\n\t\t/** Indicates whether this datastore is currently busy synching. */\r\n\t\tisSynching: function SynchableDataStore_isSynching() {return false;},\r\n\t\t\r\n\t\t/** Gets or sets the (device) date time this datastore was last synched. */\r\n\t\tlastSynched: function SynchableDataStore_lastSynched(newDate) {return newDate || new Date();},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns an 'immutable' array that represents a live view of the items\r\n\t\t * maintained in this store. \r\n\t\t * \r\n\t\t * <p>The result of this method can be used for observing/monitoring the\r\n\t\t * data set. DO NOT MUTATE THIS ARRAY!.</p>\r\n\t\t */\r\n\t\titems: function SynchableDataStore_items() {},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that have been added to the store since the last synch. */\r\n\t\tcreatedItems: function SynchableDataStore_createdItems() {return [];},\r\n\t\t\r\n\t\t/** 'Immutable' array of the original versions of items that have been updated since the last synch. */\r\n\t\tupdatedItems: function SynchableDataStore_updatedItems() {return [];},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that have been deleted since the last synch. */\r\n\t\tdeletedItems: function SynchableDataStore_deletedItems() {return [];},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that could not be saved during the last synch because they went stale. */\r\n\t\tstaleItems: function SynchableDataStore_staleItems() {return [];},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that could not be saved during the last synch because they had errors. */\r\n\t\tfailedItems: function SynchableDataStore_failedItems() {return [];},\r\n\t\t\r\n\t\t/** \r\n\t\t * 'Immutable' array of items that were already updated when a synch started and were then updated again while synch was in progress.\r\n\t\t *  These items are effectively stale, but because the user edited his own items, we can safely assume\r\n\t\t *  he wishes to overwrite the remote version with the item that is in this list.\r\n\t\t */\r\n\t\tfutureItems: function SynchableDataStore_failedItems() {return [];},\r\n\r\n\t\t/** \r\n\t\t * Synchronous equivalent of <code>save</code>.\r\n\t\t * \r\n\t\t * <p>The arrays returned by <code>updatedItems</code>, <code>createdItems</code>\r\n\t\t * and <code>removedItems</code> will be updated to reflect the changes made\r\n\t\t * to the datastore since the last synch.</p>\r\n\t\t */\r\n\t\tset: function SynchableDataStore_set(item) {return item},\r\n\t\t\r\n\t\t/**\r\n\t\t * Synchronous equivalent of <code>delete</code>.\r\n\t\t *  \r\n\t\t * <p>The arrays returned by <code>updatedItems</code>, <code>createdItems</code>\r\n\t\t * and <code>removedItems</code> will be updated to reflect the changes made\r\n\t\t * to the datastore since the last synch.</p>\r\n\t\t */\r\n\t\tdel: function SynchableDataStore_del(item) {return item},\r\n//\t\t/ABSTRACT------------------------------------------------------------------------\r\n\t\t\r\n\t\ttoString: function SynchableDataStore_toString($super) {\r\n\t\t\tvar s = $super();\r\n\t\t\ts = s.substring(0, s.length - 2);\r\n\t\t\treturn '[Object ' + this.constructor.classname + ' \\'' + this.name + '\\' {' + \r\n\t\t\t\t\t'url: \\'' + this.url + '\\', ' + \r\n\t\t\t\t\t'lastSynched:' + this.lastSynched() + ', ' + \r\n\t\t\t\t\t'items:' + this.items().length + ', ' + \r\n\t\t\t\t\t'created:' + this.createdItems().length + ', ' + \r\n\t\t\t\t\t'updated:' + this.updatedItems().length + ', ' + \r\n\t\t\t\t\t'deleted:' + this.deletedItems().length + ', ' + \r\n\t\t\t\t\t'stale:' + this.staleItems().length + ', ' +\r\n\t\t\t\t\t'failed:' + this.failedItems().length + '}]';\r\n\t\t}\r\n\t});\r\n\t\r\n\t\r\n\treturn SynchableDataStore;\r\n});\r\n\n","define('bridalapp/persistent',['bridalapp/class', 'suid'], function (Class, Suid) {\r\n\tvar Persistent = Class('Persistent', {\r\n\t\tinitialize: function Persistent_initialize(obj) {\r\n\t\t\tthis.id = (obj && obj.id) || Suid(0);\r\n\t\t\tthis.type = this.constructor.classname;\r\n\t\t\tthis.version = obj && (obj.version !== undefined) ? obj.version : null;\r\n\t\t},\r\n\t\t\r\n\t\tequals: function Persistent_equals(other){\r\n\t\t\treturn other && (\r\n\t\t\t\t\t(other instanceof Persistent && other.id.value === this.id.value) ||\r\n\t\t\t\t\t(other instanceof Suid && other.value === this.id.value) || \r\n\t\t\t\t\t(other == this.id.value) \r\n\t\t\t) ;\r\n\t\t},\r\n\t\t\r\n\t\ttoString: function Persistent_toString() {\r\n\t\t\treturn '[Object ' + this.type + ' ' + this.id.toString() + ' v' + this.version + ']';\r\n\t\t}\r\n\t});\r\n\t\r\n\tPersistent.revive = function Persistent_revive(key, value) {\r\n\t\tvar t = value && typeof value === 'object' && typeof value.type === 'string' && value.type,\r\n\t\t\tconstructor = Class.subclass(Persistent, t);\r\n\t\treturn constructor ? new constructor(value) : Suid.revive(key, value);\r\n\t}; \r\n\t\r\n\tPersistent.fromJSON = function Persistent_fromJSON(json) {\r\n\t\treturn JSON.parse(json, Persistent.revive);\r\n\t};\r\n\t\r\n\tPersistent.persistent = function Persistent_persistent(arg) {\r\n\t\tif (arguments.length === 1) {return arg instanceof Persistent && arg.version !== null;}\r\n\t\tvar results = [];\r\n\t\tfor (var i=0; arg=arguments[i]; i++) {\r\n\t\t\tif (Persistent.persistent(arg)) {results.push(arg);}\r\n\t\t\telse if ('length' in arg){\r\n\t\t\t\tfor (var j=0, item; item=arg[j]; j++) {\r\n\t\t\t\t\tif (Persistent.persistent(item)) {results.push(item);}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.equals = function Persistent_static_equals(one, other, comparator) {\r\n\t\treturn (one == other ||\r\n\t\t\t\t(comparator && comparator(one, other) === 0) ||\r\n\t\t\t\tone && one.equals && one.equals(other) ||\r\n\t\t\t\tother && other.equals && other.equals(one) ||\r\n\t\t\t\t(typeof one === 'object' && one && one.valueOf() == other) ||\r\n\t\t\t\t(typeof other === 'object' && other && other.valueOf() == one));\r\n\t};\r\n\t\r\n\t// returns index of given element in given list, using given comparator\r\n\tPersistent.indexOf = function Persistent_indexOf(list, element, comparator) {\r\n\t\tfor (var i=0, item; item=list[i]; i++) {\r\n\t\t\tif (Persistent.equals(item, element)) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t};\r\n\r\n\t// CRITERIA on the cheap\r\n\tPersistent.matches = function Persistent_matches(items, criteria) {\r\n\t\tvar results = Array.prototype.concat.call(items || []);\r\n\t\tif (criteria) {\r\n\t\t\tfor (var i=results.length-1; i>=0; i--) {\r\n\t\t\t\tfor (var key in criteria) {\r\n\t\t\t\t\tif (criteria.hasOwnProperty(key)) {\r\n\t\t\t\t\t\tif ((((Array.isArray && Array.isArray(criteria[key])) || (criteria[key] instanceof Array)) && (Persistent.indexOf(criteria[key], items[i][key]) === -1)) \r\n\t\t\t\t\t\t\t\t|| (! Persistent.equals(items[i][key], criteria[key]))) {\r\n\t\t\t\t\t\t\tresults.splice(i,1); \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.pluck = function Persistent_pluck(items, attr) {\r\n\t\tvar results = [];\r\n\t\tfor (var i=0,item; item=items[i]; i++) {\r\n\t\t\tif (item[attr] !== undefined) {\r\n\t\t\t\tresults.push(item[attr]); \r\n\t\t\t}\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.clone = function Persistent_clone(items) {\r\n\t\tvar results = [];\r\n\t\tif (arguments.length > 1) {return Persistent.clone(arguments);}\r\n\t\tif (! ('length' in items)) {return items instanceof Persistent && items.clone ? items.clone() : Persistent.fromJSON(JSON.stringify(items));}\r\n\t\tvar results = [];\r\n\t\tfor (var i=0, item; item=items[i]; i++) {\r\n\t\t\tresults.push(Persistent.clone(item));\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.page = function Persistent_page(results, pageSize, pageIndex) {\r\n\t\tif (pageSize) {\r\n\t\t\tvar start = (pageIndex || 0) * pageSize,\r\n\t\t\t\tend = pageIndex * (pageSize+1);\r\n\t\t\tif ((end < 0) || (end <= start) || (start > results.length)) {return [];}\r\n\t\t\treturn results.slice(Math.max(start,0), Math.min(end, results.length));\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.eachArg = function Persistent_eachArg(args, obj, fn) {\r\n\t\tif (('length' in args) && (! (args instanceof Persistent))) {\r\n\t\t\tvar results = [];\r\n\t\t\tfor (var i=0,item; item=args[i]; i++) {\r\n\t\t\t\tresults.push.apply(results, Persistent.eachArg(item, obj, fn));\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t}\r\n\t\treturn fn.call(obj, args);\r\n\t}\r\n\t\r\n\treturn Persistent;\r\n});\r\n\n","define('bridalapp/rhaboodatastore',['bridalapp/class',\r\n\t\t'bridalapp/datastore', \r\n\t\t'bridalapp/synchabledatastore', \r\n\t\t'bridalapp/persistent', \r\n\t\t'rhaboo'], \r\nfunction (Class, DataStore, SynchableDataStore, Persistent) {\r\n\t'use strict';\r\n\t\r\n\tvar RhabooDataStore = Class('RhabooDataStore', SynchableDataStore, {\r\n\r\n\t\tinitialize: function RhabooDataStore_initialize($super, name, url, cfg) {\r\n\t\t\t$super(name, url, cfg);\r\n\t\t\tif (!this.cfg.rhaboo || !this.cfg.store) { \r\n\t\t\t\tvar repoIdx = url.indexOf('://') + 3,\r\n\t\t\t\t\tstoreIdx = url.lastIndexOf('/'),\r\n\t\t\t\t\trepo = url.substring(repoIdx, storeIdx),\r\n\t\t\t\t\tstore = url.substring(storeIdx + 1);\r\n\t\t\t\tif (!this.cfg.repo) {this.cfg.repo = repo;}\r\n\t\t\t\tif (!this.cfg.store) {this.cfg.store = store;}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Loads all items from this store matching the given <code>criteria</code>.\r\n\t\t * \r\n\t\t * <p>This method returns a <code>Promise</code> that resolves to an array(-like) that should be\r\n\t\t * treated as immutable. To mutate the store, use <code>save</code> and <code>delete</code>.</p>\r\n\t\t * \r\n\t\t * @param criteria Criteria to match on. Optional. Object.\r\n\t\t * @param pageSize Limits the number of results to fetch. Optional. Number.\r\n\t\t * @param pageIndex Indicates which results to fetch. Optional. Only applies when \r\n\t\t *        <code>pageSize &gt; 0</code>. Number. \r\n\t\t * \r\n\t\t * @return A <code>Promise<code> that resolves to an 'immutable' array of items, \r\n\t\t *         possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tload: function DataStore_load(criteria, pageSize, pageIndex) {\r\n\t\t\tvar store = this;\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(this.get(criteria, pageSize, pageIndex));\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Counts the items matching the given <code>criteria</code>.\r\n\t\t * \r\n\t\t * <p>This method returns a <code>Promise</code> that resolves to the number of items that match\r\n\t\t * the given <code>criteria</code>, or to the total number of items if no <code>criteria</code> \r\n\t\t * were given. Using this number (which will be typically obtained with an efficient operation\r\n\t\t * such as <code>SELECT COUNT(..)</code>) you can calculate the number of pages for a certain\r\n\t\t * <code>pageSize</code> and thus determine the valid range for the <code>pageIndex</code>\r\n\t\t * parameter of the <code>load</code> operation.</p>\r\n\t\t * \r\n\t\t * @param criteria Criteria to match on. Optional. Object.\r\n\t\t * \r\n\t\t * @return A <code>Promise<code> that resolves to an 'immutable' array of items, \r\n\t\t *         possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tcount: function DataStore_count(criteria) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(this.len());\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Saves the given <code>item</code>(s).\r\n\t\t * \r\n\t\t * <p>Returns a <code>Promise</code> that resolves to an 'immutable' array(-like) with the added \r\n\t\t * or changed items. These items may have changes compared with the given items (such as last \r\n\t\t * modified date, version etc) so the originals are stale after this method completes.</p> \r\n\t\t * \r\n\t\t * <p>The argument can be an instance of <code>Persistent</code> or an array(-like) of instances \r\n\t\t * of <code>Persistent.</code>. Multiple arguments can be given. These are all ways to save \r\n\t\t * three persistent objects <code>a</code>, <code>b</code> and <code>c</code> (though they\r\n\t\t * differ in performance, bundling calls is quicker)</p>:\r\n\t\t * \r\n\t\t * <code><pre>\r\n\t\t * myDataStore.save(a);\r\n\t\t * myDataStore.save(b);\r\n\t\t * myDataStore.save(c);\r\n\t\t * // or\r\n\t\t * myDataStore.save(a, b, c);\r\n\t\t * // or\r\n\t\t * myDataStore.save([a,b,c]);\r\n\t\t * // or\r\n\t\t * myDataStore.save(a, [b,c]);\r\n\t\t * // etc...\r\n\t\t * </pre></code>\r\n\t\t * \r\n\t\t * <p>If we need to wait for the result of the operation, we can do so like this:</p>\r\n\t\t * \r\n\t\t * <code><pre>\r\n\t\t * myDataStore.save(myItems).then(function(results){\r\n\t\t *    // Hooray! The items are saved!\r\n\t\t *    for (var i=0, item; item=results[i]; i++) { \r\n\t\t *       // do something kick-ass with this item\r\n\t\t *       alert('Yeah! ' + item + ' is saved!'); \r\n\t\t *    }\r\n\t\t * }).catch(function(e){\r\n\t\t *    // Oh no!! Something went wrong!\r\n\t\t *    alert('There was an error: ' + e);\r\n\t\t * });\r\n\t\t * </pre></code>\r\n\t\t * \r\n\t\t * \r\n\t\t * @param  item Either a single persistent item or an array(-like) of persistent items. \r\n\t\t * @return A <code>Promise</code> that resolves to an 'immutable' array of items that were added \r\n\t\t *         or changed. Possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tsave: function DataStore_save(item) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(this.set(item));\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Permanently deletes the given <code>item</code>s.\r\n\t\t * \r\n\t\t * <p>Returns a <code>Promise</code> that yields the removed items in an array(-like). \r\n\t\t * The returned array(-like) should be treated as immutable.</p>\r\n\t\t * \r\n\t\t * <p>The argument can be an instance of Persistent or an array(-like) of instances of Persistent. \r\n\t\t * Just like with <code>save()</code>, multiple arguments can be given.</p>\r\n\t\t * \r\n\t\t * @param  item Either a single persistent item or an array(-like) of persistent items. \r\n\t\t * @return An 'immutable' array of items that were removed. Possibly empty but never <code>null</code>.\r\n\t\t */\r\n\t\tdelete: function DataStore_delete(item) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(this.del(item));\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\tset: function RhabooDataStore_set(item) {\r\n\t\t\tvar results = Persistent.eachArg(arguments, this, function(item) {\r\n\t\t\t\tvar backup = null,\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().items, item);\r\n\t\t\t\tif (idx === -1) {this.db().items.push(item);} \r\n\t\t\t\telse {backup = this.db().items.splice(idx, 1, item)[0];}\r\n\t\t\t\t\r\n\t\t\t\t// item had been deleted previously?\r\n\t\t\t\tidx = Persistent.indexOf(this.db().deleted, item);\r\n\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t// item was deleted, then added again, so effectively it was updated.\r\n\t\t\t\t\tbackup = this.db().deleted.splice(idx, 1);\r\n\t\t\t\t}\r\n\t\t\t\tif (backup) {\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().updated, item);\r\n\t\t\t\t\tif (idx === -1) {this.db().updated.push(backup);}\r\n\t\t\t\t\telse if (this.synching) {\r\n\t\t\t\t\t\t// the synch is already in progress... meaning when we get back the saved\r\n\t\t\t\t\t\t// item our new version would appear stale... So put it in future list\r\n\t\t\t\t\t\tidx = Persistent.indexOf(this.db().future, item);\r\n\t\t\t\t\t\tif (idx === -1) {this.db().future.push(item);}\r\n\t\t\t\t\t\telse {this.db().future.splice(idx, 1, item);}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn [item];\r\n\t\t\t});\r\n\t\t\tthis.trigger('change');\r\n\t\t\treturn results;\r\n\t\t},\r\n\r\n\t\tdel: function RhabooDataStore_del(item) {\r\n\t\t\tvar results = Persistent.eachArg(arguments, this, function(item) {\r\n\t\t\t\tvar backup, idx = Persistent.indexOf(this.items(), item);\r\n\t\t\t\tif (idx !== -1) {backup = this.items().splice(idx, 1)[0];}\r\n\t\t\t\tif (Persistent.persistent(item)) {\r\n\t\t\t\t\t// if item was in updated list, remove it\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().updated, item);\r\n\t\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t\tvar removed = this.db().updated.splice(idx, 1);\r\n\t\t\t\t\t\tbackup = backup || removed;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if item was in future list, remove it\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().future, item);\r\n\t\t\t\t\tif (idx !== -1) {this.db().future.splice(idx, 1);}\r\n\t\t\t\t\t// if item was not in deleted list, add it (old version if we have it)\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().deleted, item);\r\n\t\t\t\t\tif (idx === -1) {this.db().deleted.push(backup || item);}\r\n\t\t\t\t}\r\n\t\t\t\treturn [backup || item];\r\n\t\t\t});\r\n\t\t\tthis.trigger('change');\r\n\t\t\treturn results;\r\n\t\t},\r\n\t\t\r\n\t\t/** Gets or sets the (device) date time this store was last synched. */\r\n\t\tlastSynched: function RhabooDataStore_lastSynched(date) {\r\n\t\t\tif (date) {this.db().write('lastSynched', date);}\r\n\t\t\treturn this.db().lastSynched;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns an 'immutable' array that represents a live view of the items\r\n\t\t * maintained in this store. \r\n\t\t * \r\n\t\t * <p>The result of this method can be used for observing/monitoring the\r\n\t\t * data set. DO NOT MUTATE THIS ARRAY!.</p>\r\n\t\t */\r\n\t\titems: function RhabooDataStore_items() {\r\n\t\t\treturn this.db().items;\r\n\t\t},\r\n\r\n\t\t/** List of created items is calculated dynamically based on which items are not persistent yet */\r\n\t\tcreatedItems: function RhabooDataStore_createdItems() {\r\n\t\t\tvar results = [];\r\n\t\t\tfor (var i=0, item; item=this.items()[i]; i++) {\r\n\t\t\t\tif (! Persistent.persistent(item)) {results.push(item);}\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t},\r\n\t\t\r\n\t\tupdatedItems: function RhabooDataStore_updatedItems() {\r\n\t\t\treturn this.db().updated;\r\n\t\t},\r\n\t\t\r\n\t\tdeletedItems: function RhabooDataStore_deletedItems() {\r\n\t\t\treturn this.db().deleted;\r\n\t\t},\r\n\r\n\t\tstaleItems: function RhabooDataStore_staleItems() {\r\n\t\t\treturn this.db().stale;\r\n\t\t},\r\n\t\t\r\n\t\tfailedItems: function RhabooDataStore_failedItems() {\r\n\t\t\treturn this.db().failed;\r\n\t\t},\r\n\t\t\r\n\t\tfutureItems: function RhabooDataStore_futureItems() {\r\n\t\t\treturn this.db().future;\r\n\t\t},\r\n\t\t\r\n\t\tdb: function RhabooDataStore_db() {\r\n\t\t\tif (! this.cfg.rhaboo) {\r\n\t\t\t\tthis.cfg.rhaboo = Rhaboo.persistent(this.cfg.repo);\r\n\t\t\t\tif (! this.cfg.rhaboo[this.cfg.store]) {this.cfg.rhaboo.write(this.cfg.store, {});}\r\n\t\t\t\tfor (var i=0,key; key=['items', 'updated', 'deleted', 'stale', 'failed', 'future'][i]; i++) {\r\n\t\t\t\t\tif (! this.db()[key]) {this.db().write(key, []);}\r\n\t\t\t\t}\r\n\t\t\t\tif(! this.db().lastSynched) {this.db().write('lastSynched', new Date(0));}\r\n\t\t\t}\r\n\t\t\treturn this.cfg.rhaboo[this.cfg.store];\r\n\t\t}\r\n\t});\r\n\t\r\n\tDataStore.registerType('rhaboo', function RhabooDataStoreFactory(name, url, cfg) {\r\n\t\treturn new RhabooDataStore(name, url, cfg);\r\n\t});\r\n\t\r\n\treturn RhabooDataStore;\r\n});\r\n\n","define('bridalapp/log',[], function () {\r\n\tvar METHODS = ['log','info','warn','error'],\r\n\t\tout = ('console' in this) && console.error ? console : {},\r\n\t\tcon = {}, // save backups of native console functions here\r\n\t\tnul = {}, // keep empty console functions here\r\n\t\ti, key;\r\n\r\n\tfor (i=0; key=METHODS[i]; i++) {\r\n\t\tnul[key] = function(){}\r\n\t\tcon[key] = out[key] || nul[key];\r\n\t}\r\n\r\n\tfunction log() {\r\n\t\treturn out;\r\n\t}\r\n\r\n\tlog.level = function log_level(lvl) {\r\n\t\tif ((lvl !== undefined) && (lvl >= 0) && (lvl <= 4) && (lvl !== logLevel)) {\r\n\t\t\tlogLevel = lvl;\r\n\t\t\t// modify the console methods: \r\n\t\t\t// those which are below the current log level get replaced by empty functions\r\n\t\t\tfor (var i=0,fn; fn=METHODS[i]; i++) {\r\n\t\t\t\tout[fn] = i >= lvl ? con[fn] : nul[fn];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn logLevel;\r\n\t};\r\n\r\n\tlog.level.DEBUG = 0;\r\n\tlog.level.INFO = 1;\r\n\tlog.level.WARN = 2;\r\n\tlog.level.ERROR = 3;\r\n\tlog.level.NONE = 4;\r\n\t\r\n\tvar logLevel = log.level.DEBUG;\r\n\r\n\treturn log;\r\n});\r\n\n","define('bridalapp/restdatastore',['bridalapp/class', \r\n\t\t'jquery', \r\n\t\t'bridalapp/log', \r\n\t\t'bridalapp/persistent', \r\n\t\t'bridalapp/datastore'], \r\nfunction (Class, $, log, Persistent, DataStore) {\r\n\t'use strict';\r\n\t\r\n\tvar RestDataStore = Class('RestDataStore', DataStore, {\r\n\t\t\r\n\t\tinitialize: function RestDataStore_initialize($super, name, url, cfg) {\r\n\t\t\t$super(name, url, cfg);\r\n\t\t\tthis.cfg.retryCount = this.cfg.retryCount || 0;\r\n\t\t\tthis.cfg.retryWaitTime = this.cfg.retryWaitTime || 2000;\r\n\t\t\tthis.cfg.timeout = this.cfg.timeout || 10000;\r\n\t\t\tif (this.cfg.supportsSynch === undefined) {this.cfg.supportsSynch = false}\r\n\t\t},\r\n\r\n\t\tload: function RestDataStore_load(criteria, pageSize, pageIndex) {\r\n\t\t\t// TODO add criteria and paging parameters to the url\r\n\t\t\treturn this.remoteRequest('GET', this.url, {criteria: criteria, pageSize: pageSize, pageIndex: pageIndex});\r\n\t\t},\r\n\r\n\t\tcount: function RestDataStore_count(criteria) {\r\n\t\t\t// TODO do the right thing and implement a count query\r\n\t\t\t// needs work on the server side as well and not needed yet\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tthis.remoteRequest('GET', this.url, {criteria: criteria}).then(function(items){\r\n\t\t\t\t\tresolve(items.length);\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t});  \r\n\t\t},\r\n\r\n\t\tsave: function RestDataStore_save(items) {\r\n\t\t\tvar all = Persistent.eachArg(items, this, function(item){return [item];});\r\n\t\t\treturn this.remoteRequest('POST', this.url + '/save', all);\r\n\t\t},\r\n\r\n\t\tdelete: function RestDataStore_delete(items) {\r\n\t\t\tvar all = Persistent.eachArg(items, this, function(item){return [item];});\r\n\t\t\treturn this.remoteRequest('DELETE', this.url, all);\r\n\t\t},\r\n\r\n\t\tsynch: function RestDataStore_synch(synchRequest) {\r\n\t\t\treturn this.remoteRequest('POST', this.url + '/synch', synchRequest);\r\n\t\t},\r\n\r\n\t\tremoteRequest: function RestDataStore_remoteRequest(method, url, data) {\r\n\t\t\treturn (function(method, url, data, timeout, retries, retryWait){\r\n\t\t\t\tvar THROTTLE = 5000,\r\n\t\t\t\t\tstarted = Date.now(),\r\n\t\t\t\t\tstore = this;\r\n\t\t\t\t\r\n\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\tif ((method === 'GET') && data) {\r\n\t\t\t\t\t\tvar hashIdx = url.indexOf('#'),   \r\n\t\t\t\t\t\t\thash = hashIdx !== -1 ? url.substring(hashIdx) : '',\r\n\t\t\t\t\t\t\tqsIdx = url.indexOf('?'),\r\n\t\t\t\t\t\t\tqs = qsIdx !== -1 ? url.substring(qsIdx) : '';\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (data.criteria) {\r\n\t\t\t\t\t\t\tfor (var key in data.criteria) {\r\n\t\t\t\t\t\t\t\tif (data.criteria.hasOwnProperty(key)) {\r\n\t\t\t\t\t\t\t\t\tqs += (qs ? '&' : '') + encodeURIComponent(key) + '=' \r\n\t\t\t\t\t\t\t\t\t\t\t+ encodeURIComponent(data.criteria[key].toString());\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (data.pageSize) {\r\n\t\t\t\t\t\t\tqs += (qs ? '&' : '') + 'pg=' + data.pageIndex + '&pgsz=' + data.pageSize;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\turl = url + qs + hash;\r\n\t\t\t\t\t\tdata = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t\trequest(method, url, data, error, resolve, reject);\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tfunction info(data) {\r\n\t\t\t\t\tvar info = '';\r\n\t\t\t\t\tif (data) {\r\n\t\t\t\t\t\tif (data.length) {info = '(' + data.length + ' items)';}\r\n\t\t\t\t\t\telse if (data.createdItems) {\r\n\t\t\t\t\t\t\tvar parts = [];\r\n\t\t\t\t\t\t\tif (data.createdItems.length) {parts.push(data.createdItems.length + ' created');} \r\n\t\t\t\t\t\t\tif (data.updatedItems.length) {parts.push(data.updatedItems.length + ' updated');}\r\n\t\t\t\t\t\t\tif (data.deletedItems && data.deletedItems.length) {parts.push(data.deletedItems.length + ' deleted');}\r\n\t\t\t\t\t\t\tif (data.deletedIds && data.deletedIds.length) {parts.push(data.deletedIds.length + ' deleted');}\r\n\t\t\t\t\t\t\tif (parts.length) {info = '(' + parts.join(', ') + ')';}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn info;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfunction request(method, url, data, errorHandler, resolve, reject) {\r\n\t\t\t\t\tvar pre = '';\r\n\t\t\t\t\tfor (var i=0; i<6-method.length; i++) {pre += ' ';}\r\n\t\t\t\t\tlog().log(' -> ' + pre + method + ' ' + url + ' ' + info(data));\r\n\t\t\t\t\t\r\n\t\t\t\t\t$.ajax(url, {\r\n\t\t\t\t\t\tmethod: method,\r\n\t\t\t\t\t\tcontentType: 'application/json',\r\n\t\t\t\t\t\tprocessData: false,\r\n\t\t\t\t\t\tdata: data && JSON.stringify(data),\r\n\t\t\t\t\t\ttimeout: timeout\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.done(function(data, statusText, jqXHR){\r\n\t\t\t\t\t\tif (jqXHR.responseText.indexOf('j_security_check') !== -1) {\r\n\t\t\t\t\t\t\t// login challenge from server, session expired\r\n\t\t\t\t\t\t\tlog().info('401 ' + pre + method + ' ' + url + ' ' + info(data) + ' (LOGIN CHALLENGE)');\r\n\t\t\t\t\t\t\terrorHandler(jqXHR, method, url, data, resolve, reject);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tlog().info('200 ' + pre + method + ' ' + url + ' ' + info(data) + ' (OK)');\r\n\t\t\t\t\t\t\tretries = 0;\r\n\t\t\t\t\t\t\tresolve(Persistent.fromJSON(jqXHR.responseText));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.fail(function(jqXHR, textStatus, errorThrown) {\r\n\t\t\t\t\t\tjqXHR.statusText = errorThrown || textStatus; \r\n\t\t\t\t\t\tlog().warn(jqXHR.status + ' ' + pre + method + ' ' + url + ' ' + info(data) + ' (' + jqXHR.statusText + ')');\r\n\t\t\t\t\t\terrorHandler(jqXHR, method, url, data, resolve, reject);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfunction error(jqXHR, method, url, data, resolve, reject) {\r\n\t\t\t\t\t// status code 5xx ? possibly recoverable.\r\n\t\t\t\t\tvar statusText = jqXHR.statusText;\r\n\t\t\t\t\tswitch(status) {\r\n\t\t\t\t\t\tcase 500: // Internal server error\r\n\t\t\t\t\t\tcase 502: // Bad Gateway\r\n\t\t\t\t\t\tcase 503: // Service unavailable\r\n\t\t\t\t\t\tcase 504: // Gateway Timeout\r\n\t\t\t\t\t\t\tif (retries > 0) {\r\n\t\t\t\t\t\t\t\tretry(jqXHR, method, url, data, errorHandler, resolve, reject);\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tcase 200: // Happens in case of server login challenge when unauthorized\r\n\t\t\t\t\t\t\tif (jqXHR.status == 200) {\r\n\t\t\t\t\t\t\t\t// TODO handle this\r\n\t\t\t\t\t\t\t\tstatusText = 'Session expired.';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdefault: // unrecoverable or too many tries. give up \r\n\t\t\t\t\t\t\tretries = 0;\r\n\t\t\t\t\t\t\tvar err = new Error(jqXHR.status + ' ' + statusText);\r\n\t\t\t\t\t\t\terr.status = jqXHR.status;\r\n\t\t\t\t\t\t\terr.statusText = statusText;\r\n\t\t\t\t\t\t\terr.request = jqXHR;\r\n\t\t\t\t\t\t\terr.method = method;\r\n\t\t\t\t\t\t\terr.url = url;\r\n\t\t\t\t\t\t\terr.data = data;\r\n\t\t\t\t\t\t\treject(err);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfunction retry(jqXHR, method, url, data, errorHandler, resolve, reject) {\r\n\t\t\t\t\tretries--;\r\n\t\t\t\t\tvar after = 3000; // 5 minutes\r\n\t\t\t\t\tvar retryAfter = jqXHR.getResponseHeader('Retry-After');\r\n\t\t\t\t\tif (retryAfter) {\r\n\t\t\t\t\t\tvar tmp = parseInt(retryAfter, 10);\r\n\t\t\t\t\t\tif (! isNaN(tmp)) {\r\n\t\t\t\t\t\t\tafter = tmp * 1000; // seconds to ms.\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tsetTimeout(function(){\r\n\t\t\t\t\t\trequest(method, url, data, errorhandler, resolve, reject);\r\n\t\t\t\t\t}, after);\r\n\t\t\t\t}\r\n\t\t\t})(method, url, data, this.cfg.timeout, this.cfg.retryCount, this.cfg.retryWaitTime);\r\n\t\t}\r\n\t});\r\n\r\n\tfunction RestDataStoreFactory(name, url, cfg) {\r\n\t\treturn new RestDataStore(name, url, cfg);\r\n\t}\r\n\t\r\n\tDataStore.registerType('http', RestDataStoreFactory);\r\n\tDataStore.registerType('https', RestDataStoreFactory);\r\n\r\n\treturn RestDataStore;\r\n});\r\n\n","define('bridalapp/named',['bridalapp/class', 'bridalapp/persistent'], function (Class, Persistent) {\r\n\tvar Named = Class('Named', Persistent, {\r\n\t\tinitialize: function Named_initialize($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.name = (obj && obj.name) || null;\r\n\t\t},\r\n\t\t\r\n\t\ttoString: function Named_toString() {\r\n\t\t\treturn '[Object ' + this.type + ' \\'' + this.name + '\\' ' + this.id.toString() + ' v' + this.version + ']';\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn Named;\r\n});\r\n\n","define('bridalapp/account',['bridalapp/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Account = Class('Account', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.roles = (obj && obj.roles) || [];\r\n\t\t\tthis.groups = (obj && obj.groups) || [];\r\n\t\t\tthis.credentials = (obj && obj.credentials) || [];\r\n\t\t}\r\n\t});\r\n\r\n\treturn Account;\r\n});\n","define('bridalapp/brand',['bridalapp/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Brand = Class('Brand', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t}\r\n\t});\r\n\r\n\treturn Brand;\r\n});\n","define('bridalapp/synchrequest',['bridalapp/class'], function(Class){\r\n\tvar SynchRequest = Class('SynchRequest', {\r\n\t\tinitialize: function(obj) {\r\n\t\t\tthis.unsynchedDuration = (obj && obj.synchDuration) || 0;\r\n\t\t\tthis.criteria = (obj && obj.criteria) || null;\r\n\t\t\tthis.currentIds = (obj && obj.currentIds) || [];\r\n\t\t\tthis.currentVersions = (obj && obj.currentVersions) || [];\r\n\t\t\tthis.createdItems = (obj && obj.createdItems) || [];\r\n\t\t\tthis.updatedItems = (obj && obj.updatedItems) || [];\r\n\t\t\tthis.deletedItems = (obj && obj.deletedItems) || [];\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn SynchRequest;\r\n});\n","define('bridalapp/synchresponse',['bridalapp/class'], function(Class){\r\n\tvar SynchResponse = Class('SynchResponse', {\r\n\t\tinitialize: function(obj) {\r\n\t\t\tthis.createdItems = (obj && obj.createdItems) || [];\r\n\t\t\tthis.updatedItems = (obj && obj.updatedItems) || [];\r\n\t\t\tthis.staleItems = (obj && obj.staleItems) || [];\r\n\t\t\tthis.failedItems = (obj && obj.failedItems) || [];\r\n\t\t\tthis.deletedIds = (obj && obj.deletedIds) || [];\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn SynchResponse;\r\n});\n","define('bridalapp/syncheddatastore',['bridalapp/class', \r\n\t\t'jquery', \r\n\t\t'bridalapp/log', \r\n\t\t'bridalapp/persistent', \r\n\t\t'bridalapp/datastore', \r\n\t\t'bridalapp/synchabledatastore', \r\n\t\t'bridalapp/synchrequest', \r\n\t\t'bridalapp/synchresponse'], \r\n\r\nfunction (Class, $, log, Persistent, DataStore, SynchableDataStore, SynchRequest, SynchResponse) {\r\n\t'use strict';\r\n\r\n\tvar SynchedDataStore = Class('SynchedDataStore', SynchableDataStore, {\r\n\t\t\r\n\t\tinitialize: function SynchedDataStore_initialize($super, name, url, cfg) {\r\n\t\t\t$super(name, url, cfg);\r\n\t\t\tthis.synching = false;\r\n\t\t\tthis.synchError = false;\r\n\t\t\tcfg = this.cfg;\r\n\t\t\tif (cfg.autoSynch === undefined) {cfg.autoSynch = true;}\r\n\t\t\tif (!cfg.synchInterval) {cfg.synchInterval = 30 * 1000;}    // 30 sec.\r\n\t\t\tif (!cfg.pollInterval) {cfg.pollInterval = 30 * 60 * 1000;} // 30 min.\r\n\t\t\tif (cfg.remoteSynch === undefined) {cfg.remoteSynch = true;}\r\n\t\t\tif ((! cfg.localDataStore) || (! cfg.remoteDataStore)) {\r\n\t\t\t\t// url: 'synched://rhaboo/bridal-app/ratings#http/api/ratings'\r\n\t\t\t\tvar urls = url.split('://')[1].split('#');\r\n\t\t\t\tif (! cfg.localDataStore) {\r\n\t\t\t\t\tvar localParts=urls[0].split('/'), \r\n\t\t\t\t\t\tlocalType=localParts[0],\r\n\t\t\t\t\t\tlocalRepo=localParts.slice(1, localParts.length-1).join('/'),\r\n\t\t\t\t\t\tlocalStore=localParts[localParts.length-1];\r\n\t\t\t\t\tcfg.localDataStore = DataStore.fromType(name, localType, \r\n\t\t\t\t\t\t\tlocalType + '://' + localRepo + '/' + localStore);\r\n\t\t\t\t\tif (! (cfg.localDataStore instanceof SynchableDataStore)) {\r\n\t\t\t\t\t\tif (cfg.localDataStore) {\r\n\t\t\t\t\t\t\tlog().error('Unable to initialize SynchedDataStore \\'' + name + '\\'.' + \r\n\t\t\t\t\t\t\t\t\t'Need a synchable datastore for the local side, ' + \r\n\t\t\t\t\t\t\t\t\t'but ' + cfg.localDataStore + ' is not a SynchableDataStore.');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tlog().error('Unable to initialize SynchedDataStore \\'' + name + '\\'.' + \r\n\t\t\t\t\t\t\t\t\t'Need a synchable datastore for the local side, but ' + \r\n\t\t\t\t\t\t\t\t\t'could not find a datastore for url \\'' + urls[0] + '\\'.');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (! cfg.remoteDataStore) {\r\n\t\t\t\t\tvar remoteParts=urls[1].split('/'),\r\n\t\t\t\t\t\tremoteType=remoteParts[0],\r\n\t\t\t\t\t\tremoteRepo=remoteParts.slice(1, remoteParts.length-1).join('/'),\r\n\t\t\t\t\t\tremoteStore=remoteParts[remoteParts.length-1];\r\n\t\t\t\t\tcfg.remoteDataStore = DataStore.fromType(name, remoteType, '/' + remoteRepo + '/' + remoteStore);\r\n\t\t\t\t\tif (! cfg.remoteDataStore) {\r\n\t\t\t\t\t\tlog().error('Unable to initialize SynchedDataStore \\'' + name + '\\'.' + \r\n\t\t\t\t\t\t\t\t'Need a datastore for the remote side, but ' + \r\n\t\t\t\t\t\t\t\t'could not find a datastore for url \\'' + urls[1] + '\\'.');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/** \r\n\t\t * Brings this datastore back into synch.\r\n\t\t * \r\n\t\t * <p>Returns a promise that resolves on synch complete or rejects on\r\n\t\t * synch failure. The arrays returned by <code>staleItems</code> and \r\n\t\t * <code>failedItems</code> will be updated with items that could not\r\n\t\t * be saved because they had been changed on the remote server in the\r\n\t\t * meantime, or that gave (integrity constraint) validation errors,\r\n\t\t * respectively.</p> \r\n\t\t */\r\n\t\tsynch: function SynchedDataStore_synch($super, force) {\r\n\t\t\tif (this.cfg.autoSynch) {autoSynch(this);}\r\n\t\t\tvar me = this, cfg = me.cfg;\r\n\t\t\tif ((!force) && me.synching) {return me.synching;}\r\n\t\t\tme.synchError = false;\r\n\t\t\tif (! cfg.remoteDataStore.cfg.supportsSynch) {return poorMansSynch(me);}\r\n\t\t\treturn me.synching = new Promise(function(resolve, reject) {\r\n\t\t\t\t// if not forced synch and store looks synched and poll interval not expired, do nothing.\r\n\t\t\t\tif ((!force) && me.looksSynched() && (Date.now() < me.lastSynched().getTime() + cfg.pollInterval)) {\r\n\t\t\t\t\t// postpone resolving until after synch method has returned.\r\n\t\t\t\t\treturn setTimeout(function(){\r\n\t\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t},0);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// synching is needed\r\n\t\t\t\tme.trigger('synch:started');\r\n\t\t\t\tvar changed = false;\r\n\t\t\t\tvar req = new SynchRequest();\r\n\t\t\t\treq.criteria = cfg.filter || null;\r\n\t\t\t\treq.createdItems.push.apply(req.createdItems, me.createdItems());\r\n\t\t\t\treq.updatedItems.push.apply(req.updatedItems, me.updatedItems());\r\n\t\t\t\treq.deletedItems.push.apply(req.deletedItems, me.deletedItems());\r\n\t\t\t\treq.currentIds.push.apply(req.currentIds, Persistent.pluck(me.items(), 'id'));\r\n\t\t\t\treq.currentVersions.push.apply(req.currentVersions, Persistent.pluck(me.items(), 'version'));\r\n\r\n\t\t\t\tcfg.remoteDataStore.synch(req).then(function(response) {\r\n\t\t\t\t\tvar i,id,idx,item;\r\n\r\n\t\t\t\t\t// handle deleted items\r\n\t\t\t\t\tif (response.deletedIds.length) {\r\n\t\t\t\t\t\tfor (i=0; id=response.deletedIds[i]; i++) {\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.items(), id);\r\n\t\t\t\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t\t\t\tme.items().splice(idx, 1);\r\n\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.deletedItems(), id);\r\n\t\t\t\t\t\t\tif (idx !== -1) {me.deletedItems().splice(idx, 1);}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.deletedIds.length + ' deleted items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// handle updated items\r\n\t\t\t\t\tif (response.updatedItems.length) {\r\n\t\t\t\t\t\tfor (i=0; item=response.updatedItems[i]; i++) {\r\n\t\t\t\t\t\t\t// if we have futureItems, try to merge the changes into the new version of the item\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.futureItems(), item)\r\n\t\t\t\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t\t\t\t// get future item and remove from list\r\n\t\t\t\t\t\t\t\tvar future = me.futureItems().splice(idx, 1)[0];\r\n\t\t\t\t\t\t\t\t// replace updated item with version from server\r\n\t\t\t\t\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\t\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1, item);}\r\n\t\t\t\t\t\t\t\telse {me.updatedItems().push(item);}\r\n\t\t\t\t\t\t\t\t// now merge changes from future item onto server item\r\n\t\t\t\t\t\t\t\tvar merged = Persistent.clone(item);\r\n\t\t\t\t\t\t\t\tfor (var key in future) {\r\n\t\t\t\t\t\t\t\t\tif (key !== 'version') {\r\n\t\t\t\t\t\t\t\t\t\tmerged[key] = future[key]; \r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// replace item with the merged version\r\n\t\t\t\t\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\t\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t\t\t\t\tme.items().splice(idx, 1, merged);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t// remove saved item from the updatedItems list\r\n\t\t\t\t\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\t\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1);}\r\n\t\t\t\t\t\t\t\telse {changed = true;}\r\n\t\t\t\t\t\t\t\t// replace item with the saved version\r\n\t\t\t\t\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\t\t\t\t\tif (idx !== -1) {me.items().splice(idx, 1, item);}\r\n\t\t\t\t\t\t\t\telse {me.items().push(item);}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.updatedItems.length + ' updated items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// handle created items\r\n\t\t\t\t\tif (response.createdItems.length) {\r\n\t\t\t\t\t\tfor (i=0; item=response.createdItems[i]; i++) {\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\t\t\t\tif (idx === -1) {\r\n\t\t\t\t\t\t\t\tme.items().push(item);\r\n\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {me.items().splice(idx, 1, item);}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.createdItems.length + ' created items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// handle stale items\r\n\t\t\t\t\tif (response.staleItems.length) {\r\n\t\t\t\t\t\tfor (i=0; item=response.staleItems[i]; i++) {\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.staleItems(), item);\r\n\t\t\t\t\t\t\tif (idx === -1) {me.staleItems().push(item);}\r\n\t\t\t\t\t\t\telse {me.staleItems().splice(idx, 1, item);}\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.createdItems(), item);\r\n\t\t\t\t\t\t\tif (idx !== -1) {me.createdItems().splice(idx, 1);}\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1);}\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.deletedItems(), item);\r\n\t\t\t\t\t\t\tif (idx !== -1) {me.deletedItems().splice(idx, 1);}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.staleItems.length + ' stale items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (response.failedItems.length) {\r\n\t\t\t\t\t\t// handle failed items\r\n\t\t\t\t\t\tfor (i=0; item=response.failedItems[i]; i++) {\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.failedItems(), item);\r\n\t\t\t\t\t\t\tif (idx === -1) {me.failedItems().push(item);}\r\n\t\t\t\t\t\t\telse {me.failedItems().splice(idx, 1, item);}\r\n\t\t\t\t\t\t\tif (Persistent.indexOf(me.createdItems(), item) !== -1) {\r\n\t\t\t\t\t\t\t\t// created items is a virtual array, remove from items\r\n\t\t\t\t\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\t\t\t\t\tif (idx !== -1) {me.items().splice(idx, 1);}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1);}\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.deletedItems(), item);\r\n\t\t\t\t\t\t\tif (idx !== -1) {me.deletedItems().splice(idx, 1);}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.failedItems.length + ' failed items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tme.lastSynched(new Date());\r\n\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\tif (changed) {me.trigger('change');} \r\n\t\t\t\t\tme.trigger('synch:success');\r\n\t\t\t\t\tresolve();\r\n\t\t\t\t\tme.trigger('synch:done');\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\tme.synchError = e;\r\n\t\t\t\t\tme.trigger('synch:failed');\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t\tme.trigger('synch:done');\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/** Indicates whether this datastore is currently busy synching. */\r\n\t\tisSynching: function SynchedDataStore_isSynching() {\r\n\t\t\treturn !!this.synching;\r\n\t\t},\r\n\r\n\t\t// IMPLEMENT ALL ABSTRACT METHODS.\r\n\t\t// ASYNCH methods will call synch to try to make sure after the call the results\r\n\t\t// are consistent for both the local as well as the remote datastore.\r\n\t\tload: function SynchedDataStore_load(criteria, pageSize, pageIndex) {\r\n\t\t\tvar me = this;\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tthis.synch().then(function(){\r\n\t\t\t\t\tme.cfg.localDataStore.load(criteria, pageSize, pageIndex).then(function(items){\r\n\t\t\t\t\t\tresolve(items);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}); \r\n\t\t},\r\n\r\n\t\tcount: function SynchedDataStore_count(criteria) {\r\n\t\t\tvar me = this;\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tthis.synch().then(function(){\r\n\t\t\t\t\tme.cfg.localDataStore.count(criteria, pageSize, pageIndex).then(function(count){\r\n\t\t\t\t\t\tresolve(count);\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}); \r\n\t\t},\r\n\r\n\t\tsave: function SynchedDataStore_save(item) {\r\n\t\t\tvar me = this;\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tme.cfg.localDataStore.save(item).then(function(items){\r\n\t\t\t\t\tme.synch().then(function(){\r\n\t\t\t\t\t\tresolve(items);\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}); \r\n\t\t},\r\n\r\n\t\tdelete: function SynchedDataStore_delete(item) {\r\n\t\t\tvar me = this;\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tme.cfg.localDataStore.delete(item).then(function(items){\r\n\t\t\t\t\tme.synch().then(function(){\r\n\t\t\t\t\t\tresolve(items);\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}); \r\n\t\t},\r\n\t\t\r\n\t\t// synchronous methods will interact with the local datastore only (remote does not support synchronous invocation)\r\n\t\t/** Gets or sets the (local/device) date time this datastore was last synched. */\r\n\t\tlastSynched: function SynchedDataStore_lastSynched(newDate) {\r\n\t\t\treturn this.cfg.localDataStore.lastSynched(newDate);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns an 'immutable' array that represents a live view of the items\r\n\t\t * maintained in this store. \r\n\t\t * \r\n\t\t * <p>The result of this method can be used for observing/monitoring the\r\n\t\t * data set. DO NOT MUTATE THIS ARRAY!.</p>\r\n\t\t */\r\n\t\titems: function SynchedDataStore_items() {\r\n\t\t\treturn this.cfg.localDataStore.items();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that have been added to the store since the last synch. */\r\n\t\tcreatedItems: function SynchedDataStore_createdItems() {\r\n\t\t\treturn this.cfg.localDataStore.createdItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of the original versions of items that have been updated since the last synch. */\r\n\t\tupdatedItems: function SynchedDataStore_updatedItems() {\r\n\t\t\treturn this.cfg.localDataStore.updatedItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that have been deleted since the last synch. */\r\n\t\tdeletedItems: function SynchedDataStore_deletedItems() {\r\n\t\t\treturn this.cfg.localDataStore.deletedItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that could not be saved during the last synch because they went stale. */\r\n\t\tstaleItems: function SynchedDataStore_staleItems() {\r\n\t\t\treturn this.cfg.localDataStore.staleItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that could not be saved during the last synch because they had errors. */\r\n\t\tfailedItems: function SynchedDataStore_failedItems() {\r\n\t\t\treturn this.cfg.localDataStore.failedItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** \r\n\t\t * 'Immutable' array of items that were already updated when a synch started and were then updated again while synch was in progress.\r\n\t\t *  These items are effectively stale, but because the user edited his own items, we can safely assume\r\n\t\t *  he wishes to overwrite the remote version with the item that is in this list.\r\n\t\t */\r\n\t\tfutureItems: function SynchedDataStore_futureItems() {\r\n\t\t\treturn this.cfg.localDataStore.futureItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** \r\n\t\t * Synchronous equivalent of <code>save</code>.\r\n\t\t * \r\n\t\t * <p>The arrays returned by <code>updatedItems</code>, <code>createdItems</code>\r\n\t\t * and <code>removedItems</code> will be updated to reflect the changes made\r\n\t\t * to the datastore since the last synch.</p>\r\n\t\t */\r\n\t\tset: function SynchedDataStore_set(item) {\r\n\t\t\treturn this.cfg.localDataStore.set(item);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Synchronous equivalent of <code>delete</code>.\r\n\t\t *  \r\n\t\t * <p>The arrays returned by <code>updatedItems</code>, <code>createdItems</code>\r\n\t\t * and <code>removedItems</code> will be updated to reflect the changes made\r\n\t\t * to the datastore since the last synch.</p>\r\n\t\t */\r\n\t\tdel: function SynchedDataStore_del(item) {\r\n\t\t\treturn this.cfg.localDataStore.del(item);\r\n\t\t}\r\n\t});\r\n\r\n\tDataStore.registerType('synched', function SynchedDataStoreFactory(name, url, cfg) {\r\n\t\treturn new SynchedDataStore(name, url, cfg);\r\n\t});\r\n\t\r\n\tfunction handleLoadedItems(me, items) {\r\n\t\tvar item, old, idx, changed=false;\r\n\t\t// all items we got from the remote should be added if we did not have them on local,\r\n\t\t// or updated locally if the version we got from the remote was different. only the \r\n\t\t// remote updates the version, so it being different means our version is older.\r\n\t\tfor (var i=0; item=items[i]; i++) {\r\n\t\t\tidx = Persistent.indexOf(me.items(), item); \r\n\t\t\tif (idx === -1) {\r\n\t\t\t\t// item is not in local. either it's new on remote, or was deleted on local\r\n\t\t\t\tidx = Persistent.indexOf(me.deletedItems(), item);\r\n\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t// item was deleted on local. check version\r\n\t\t\t\t\tif (item.version !== me.deletedItems()[idx].version) {\r\n\t\t\t\t\t\t// item was deleted locally, but edited on server, so our deleted\r\n\t\t\t\t\t\t// version becomes stale, but as we deleted it we don't care and\r\n\t\t\t\t\t\t// don't add it to stale. We just remove it from deletedItems.\r\n\t\t\t\t\t\tme.deletedItems().splice(idx, 1);\r\n\t\t\t\t\t\t// add the new version of the item we had deleted\r\n\t\t\t\t\t\tme.items().push(item);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// item is new on remote\r\n\t\t\t\t\tme.items().push(item);\r\n\t\t\t\t}\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// item is already in local. check version\r\n\t\t\t\tif (item.version !== me.items()[idx].version) {\r\n\t\t\t\t\t// local version is older than remote version. replace\r\n\t\t\t\t\told = me.items().splice(idx, 1, item)[0]; \r\n\t\t\t\t\t// if we had updated this item, the update went stale\r\n\t\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), old); \r\n\t\t\t\t\tif (idx !== -1){\r\n\t\t\t\t\t\t// changed item was updated, so went stale\r\n\t\t\t\t\t\tme.updatedItems().splice(idx, 1);\r\n\t\t\t\t\t\tidx = Persistent.indexOf(me.staleItems(), old); \r\n\t\t\t\t\t\tif (idx === -1) {me.staleItems().push(old);}\r\n\t\t\t\t\t\telse {me.staleItems().splice(idx, 1, old);}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tchanged = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// all items we did NOT get from the remote should be removed locally, \r\n\t\t// except for newly created ones\r\n\t\tfor (var i=me.items().length-1; i>=0; i--) {\r\n\t\t\titem = me.items()[i];\r\n\t\t\tif ((Persistent.indexOf(items, item) === -1) &&\r\n\t\t\t\t(Persistent.indexOf(me.createdItems(), item) === -1)){ \r\n\t\t\t\t// item is not new, but does not exist (any more) on the remote\r\n\t\t\t\tvar old = me.items().splice(i, 1)[0];\r\n\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), old);\r\n\t\t\t\tif (idx !== -1) { \r\n\t\t\t\t\t// removed item was updated locally, so went stale\r\n\t\t\t\t\tthis.updatedItems().splice(idx, 1);\r\n\t\t\t\t\tidx = Persistent.indexOf(me.staleItems(), old); \r\n\t\t\t\t\tif (staleIdx === -1) {me.staleItems().push(old);}\r\n\t\t\t\t\telse {me.staleItems().splice(idx, 1, old);}\r\n\t\t\t\t}\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (changed) {me.trigger('change');}\r\n\t}\r\n\r\n\tfunction handleSavedItems(me, items) {\r\n\t\tfor (var i=0,item; item=items[i]; i++) {\r\n\t\t\t// if we have futureItems, try to merge the changes into the new version of the item\r\n\t\t\tvar idx = Persistent.indexOf(me.futureItems(), item)\r\n\t\t\tif (idx !== -1) {\r\n\t\t\t\tvar future = me.futureItems().splice(idx, 1)[0];\r\n\t\t\t\t// replace updatedItems with version from server\r\n\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1, item);}\r\n\t\t\t\telse {me.updatedItems().push(item);}\r\n\t\t\t\t// now merge changes from future item onto server item\r\n\t\t\t\tvar merged = Persistent.clone(item);\r\n\t\t\t\tfor (var key in future) {\r\n\t\t\t\t\tif (key !== 'version') {\r\n\t\t\t\t\t\tmerged[key] = future[key]; \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// replace items with the merged version\r\n\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\tif (idx !== -1) {me.items().splice(idx, 1, merged);}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// remove saved item from the updatedItems list\r\n\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1);}\r\n\t\t\t\t// replace items with the saved version\r\n\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\tif (idx !== -1) {me.items().splice(idx, 1, item);}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction handleDeletedItems(me, items) {\r\n\t\tfor (var i=0,item; item=items[i]; i++) {\r\n\t\t\tvar idx = Persistent.indexOf(me.deletedItems(), item);\r\n\t\t\tif (idx !== -1) {me.deletedItems().splice(idx, 1);}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction poorMansSynch(me) {\r\n\t\tvar cfg = me.cfg;\r\n\t\treturn me.synching = new Promise(function(resolve, reject) {\r\n\t\t\t// if store looks synched and poll interval not expired, do nothing.\r\n\t\t\tif (me.looksSynched() && (Date.now() < me.lastSynched().getTime() + cfg.pollInterval)) {\r\n\t\t\t\t// postpone resolving until after synch method has returned.\r\n\t\t\t\treturn setTimeout(function(){\r\n\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\tresolve();\r\n\t\t\t\t},0);\r\n\t\t\t}\r\n\t\t\t// synching is needed\r\n\t\t\tme.trigger('synch:started');\r\n\t\t\tcfg.remoteDataStore.load().then(function(items) {\r\n\t\t\t\t// handle loaded items, save dirty items and delete removed items\r\n\t\t\t\thandleLoadedItems(me, items);\r\n\t\t\t\t// now that we processed all loaded items we can save our changes.\r\n\t\t\t\t// Make a snapshot of current state: dirty and deleted items.\r\n\t\t\t\tvar dirty = me.createdItems().concat();\r\n\t\t\t\tfor (var i=0,item; item=me.updatedItems()[i]; i++) {\r\n\t\t\t\t\t// The items in updated are the old versions, so get the corresponding new version\r\n\t\t\t\t\tvar idx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\t\tif (idx !== -1) {dirty.push(me.items()[idx]);}\r\n\t\t\t\t}\r\n\t\t\t\tvar deleted = me.deletedItems().concat();\r\n\t\t\t\t// delete items first\r\n\t\t\t\tnew Promise(function(resolve, reject){\r\n\t\t\t\t\tif (! deleted.length) {resolve(); return;}\r\n\t\t\t\t\tcfg.remoteDataStore.delete(deleted).then(function(items){\r\n\t\t\t\t\t\thandleDeletedItems(me, items);\r\n\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).then(function(){\r\n\t\t\t\t\t// items are deleted, now we can create new, or update\r\n\t\t\t\t\tnew Promise(function(resolve, reject){\r\n\t\t\t\t\t\tif (! dirty.length) {resolve(); return;}\r\n\t\t\t\t\t\tcfg.remoteDataStore.save(dirty).then(function(items){\r\n\t\t\t\t\t\t\thandleSavedItems(me, items);\r\n\t\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}).then(function(){\r\n\t\t\t\t\t\tme.lastSynched(new Date());\r\n\t\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\t\tme.synchError = false;\r\n\t\t\t\t\t\tme.trigger('synch:success');\r\n\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t\tme.trigger('synch:done');\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}).catch(function(e) {\r\n\t\t\t\t// load failed\r\n\t\t\t\tme.synching = false;\r\n\t\t\t\tme.synchError = e;\r\n\t\t\t\tme.trigger('synch:failed');\r\n\t\t\t\treject(e);\r\n\t\t\t\tme.trigger('synch:done');\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\tfunction autoSynch(me) {\r\n\t\tif (! me.autoSynchActive) {\r\n\t\t\tme.autoSynchActive = true;\r\n\t\t\tsetInterval(function(){\r\n\t\t\t\tme.synch();\r\n\t\t\t}, me.cfg.synchInterval);\r\n\t\t}\r\n\t}\r\n\r\n\treturn SynchedDataStore;\r\n});\r\n\n","define('bridalapp/brands',['bridalapp/class', \r\n\t\t'bridalapp/syncheddatastore',\r\n\t\t'bridalapp/rhaboodatastore', \r\n\t\t'bridalapp/restdatastore',\r\n],\r\nfunction (Class, SynchedDataStore) {\r\n\tvar Brands = Class('Brands', SynchedDataStore, {\r\n\t\tinitialize: function Brands_initialize($super) {\r\n\t\t\t$super('brands', 'synched://rhaboo/bridal-app/brands#http/api/brands');\r\n\t\t}\r\n\t});\r\n\r\n\treturn new Brands();\r\n});\r\n\n","define('bridalapp/category',['bridalapp/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Category = Class('Category', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t}\r\n\t});\r\n\r\n\treturn Category;\r\n});\n","define('bridalapp/credential',['bridalapp/class', 'bridalapp/persistent'], function(Class, Persistent){\r\n\tvar Credential = Class('Credential', Persistent, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn Credential;\r\n});\n","define('bridalapp/group',['bridalapp/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Group = Class('Group', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.description = (obj && obj.description) || null;\r\n\t\t}\r\n\t});\r\n\r\n\treturn Group;\r\n});\n","define('bridalapp/password-credential',['bridalapp/class', 'bridalapp/credential'], function(Class, Credential){\r\n\tvar PasswordCredential = Class('PasswordCredential', Credential, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.password = (obj && obj.password) || null;\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn PasswordCredential;\r\n});\n","define('bridalapp/product',['bridalapp/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Product = Class('Product', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.description = (obj && obj.description) || null;\r\n\t\t\tthis.priceWholesaleEuroCent = (obj && obj.priceWholesaleEuroCent) || null;\r\n\t\t\tthis.priceConsumerEuroCent = (obj && obj.priceConsumerEuroCent) || null;\r\n\t\t\tthis.brandId = (obj && obj.brandId) || null;\r\n\t\t\tthis.brandName = (obj && obj.brandName) || null;\r\n\t\t\tthis.categoryId = (obj && obj.categoryId) || null;\r\n\t\t\tthis.categoryName = (obj && obj.categoryName) || null;\r\n\t\t\tthis.tags = (obj && obj.tags) || null;\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn Product;\r\n});\n","define('bridalapp/products',['bridalapp/class', \r\n\t\t'bridalapp/syncheddatastore', \r\n\t\t'bridalapp/rhaboodatastore', \r\n\t\t'bridalapp/restdatastore',\r\n], \r\nfunction (Class, SynchedDataStore) {\r\n\tvar Products = Class('Products', SynchedDataStore, {\r\n\t\tinitialize: function Products_initialize($super) {\r\n\t\t\t$super('products', 'synched://rhaboo/bridal-app/products#http/api/products');\r\n\t\t\tthis.cfg.remoteDataStore.cfg.supportsSynch = true;\r\n\t\t}\r\n\t});\r\n\r\n\treturn new Products();\r\n});\r\n\n","define('bridalapp/rating',['bridalapp/class', 'bridalapp/persistent'], function(Class, Persistent){\r\n\tvar Rating = Class('Rating', Persistent, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.productId = (obj && obj.productId) || null;\r\n\t\t\tthis.accountId = (obj && obj.accountId) || null;\r\n\t\t\tthis.score = (obj && obj.score) || null;\r\n\t\t}\r\n\t});\r\n\r\n\treturn Rating;\r\n});\n","define('bridalapp/ratings',['bridalapp/class', \r\n\t\t'bridalapp/syncheddatastore',\r\n\t\t'bridalapp/rhaboodatastore',\r\n\t\t'bridalapp/restdatastore',\r\n], \r\nfunction (Class, SynchedDataStore) {\r\n\tvar Ratings = Class('Ratings', SynchedDataStore, {\r\n\t\tinitialize: function Ratings_initialize($super) {\r\n\t\t\t$super('ratings', 'synched://rhaboo/bridal-app/ratings#http/api/ratings');\r\n\t\t\tthis.cfg.remoteDataStore.cfg.supportsSynch = true;\r\n\t\t}\r\n\t});\r\n\r\n\treturn new Ratings();\r\n});\r\n\n","define('bridalapp/role',['bridalapp/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Role = Class('Role', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t}\r\n\t});\r\n\r\n\treturn Role;\r\n});\n","/**!\r\n * @copyright (c) 2015 by Stijn de Witt. Some rights reserved.\r\n * @license <a href=\"https://creativecommons.org/licenses/by/4.0/\">Attribution 4.0 International (CC BY 4.0)</a> \r\n */\r\ndefine('bridalapp',[\r\n\t\t'bridalapp/rhaboodatastore',\r\n\t\t'bridalapp/restdatastore',\r\n\t\t// Pull in all classes\r\n\t\t'bridalapp/account', \r\n\t\t'bridalapp/brand',\r\n\t\t'bridalapp/brands',\r\n\t\t'bridalapp/category',\r\n\t\t'bridalapp/credential',\r\n\t\t'bridalapp/group',\r\n\t\t'bridalapp/log', \r\n\t\t'bridalapp/named',\r\n\t\t'bridalapp/password-credential', \r\n\t\t'bridalapp/persistent',\r\n\t\t'bridalapp/product',\r\n\t\t'bridalapp/products',\r\n\t\t'bridalapp/rating',\r\n\t\t'bridalapp/ratings',\r\n\t\t'bridalapp/role'\r\n\t], \r\n\t\r\nfunction(\r\n\tRhabooDataStore,\r\n\tRestDataStore,\r\n\tAccount, \r\n\tBrand,\r\n\tBrands,\r\n\tCategory,\r\n\tCredential,\r\n\tGroup,\r\n\tlog,\r\n\tNamed,\r\n\tPasswordCredential, \r\n\tPersistent,\r\n\tProduct,\r\n\tProducts,\r\n\tRating,\r\n\tRatings,\r\n\tRole\r\n){\r\n\t// Create a namespace with all classes in it and return it\r\n\treturn {\r\n\t\tAccount: Account, \r\n\t\tBrand: Brand,\r\n\t\tBrands: Brands,\r\n\t\tCategory: Category,\r\n\t\tCredential: Credential,\r\n\t\tGroup: Group,\r\n\t\tlog: log,\r\n\t\tNamed: Named,\r\n\t\tPasswordCredential: PasswordCredential, \r\n\t\tPersistent: Persistent,\r\n\t\tProduct: Product,\r\n\t\tProducts: Products,\r\n\t\tRating: Rating,\r\n\t\tRatings: Ratings,\r\n\t\tRole: Role,\r\n\t\t\r\n\t\tglobalize: function(global){\r\n\t\t\tfor (var key in this) {\r\n\t\t\t\tif (this.hasOwnProperty(key)) {\r\n\t\t\t\t\tglobal[key] = this[key];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n);\n"]}