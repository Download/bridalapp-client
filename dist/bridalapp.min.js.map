{"version":3,"file":"bridalapp.min.js","sources":["bridalapp/class.js","bridalapp/datastore.js","bridalapp/synchabledatastore.js","bridalapp/persistent.js","bridalapp/rhaboodatastore.js","bridalapp/log.js","bridalapp/restdatastore.js","bridalapp/named.js","bridalapp/account.js","bridalapp/brand.js","bridalapp/synchrequest.js","bridalapp/synchresponse.js","bridalapp/syncheddatastore.js","bridalapp/brands.js","bridalapp/category.js","bridalapp/credential.js","bridalapp/group.js","bridalapp/password-credential.js","bridalapp/product.js","bridalapp/products.js","bridalapp/rating.js","bridalapp/ratings.js","bridalapp/role.js","bridalapp.js"],"names":["define","Class","name","parent","args","arrayify","arguments","String","shift","classname","eval","klass","superclass","subclasses","subclass","prototype","push","i","len","length","addMethods","initialize","constructor","argumentNames","fn","names","toString","match","split","replace","it","Object","toArray","results","Array","bind","func","undefined","obj","splice","apply","concat","wrap","wrapper","this","src","keys","key","ancestor","props","val","argNames","method","m","valueOf","sub","subsub","DataStore","url","cfg","listeners","throttle","on","event","listener","trigger","me","triggered","Date","now","timeout","clearTimeout","setTimeout","call","off","load","Promise","resolve","count","save","item","delete","typeFactories","registerType","type","factory","fromType","fromUrl","idx","indexOf","s","substring","Suid","SynchableDataStore","$super","get","criteria","pageSize","pageIndex","clone","items","Persistent","page","matches","looksSynched","lastSynched","getTime","createdItems","updatedItems","deletedItems","synch","isSynching","newDate","staleItems","failedItems","futureItems","set","del","id","version","equals","other","value","revive","t","fromJSON","json","JSON","parse","persistent","arg","j","one","comparator","list","element","hasOwnProperty","isArray","pluck","attr","stringify","start","end","slice","Math","max","min","eachArg","RhabooDataStore","rhaboo","store","repoIdx","storeIdx","lastIndexOf","repo","backup","db","deleted","updated","synching","future","removed","date","write","stale","failed","Rhaboo","log","out","METHODS","console","error","con","nul","level","lvl","logLevel","DEBUG","INFO","WARN","ERROR","NONE","$","RestDataStoreFactory","RestDataStore","retryCount","retryWaitTime","supportsSynch","remoteRequest","reject","then","e","all","synchRequest","data","retries","info","parts","deletedIds","join","request","errorHandler","pre","ajax","contentType","processData","done","statusText","jqXHR","responseText","fail","textStatus","errorThrown","warn","status","retry","err","Error","after","retryAfter","getResponseHeader","tmp","parseInt","isNaN","errorhandler","hashIdx","hash","qsIdx","qs","encodeURIComponent","Named","Account","roles","groups","credentials","Brand","SynchRequest","unsynchedDuration","synchDuration","currentIds","currentVersions","SynchResponse","handleLoadedItems","old","changed","staleIdx","handleSavedItems","merged","handleDeletedItems","poorMansSynch","pollInterval","remoteDataStore","dirty","synchError","autoSynch","autoSynchActive","setInterval","synchInterval","SynchedDataStore","remoteSynch","localDataStore","urls","localParts","localType","localRepo","localStore","remoteParts","remoteType","remoteRepo","remoteStore","force","req","filter","response","Brands","Category","Credential","Group","description","PasswordCredential","password","Product","priceWholesaleEuroCent","priceConsumerEuroCent","brandId","brandName","categoryId","categoryName","tags","Products","Rating","productId","accountId","score","Ratings","Role","globalize","global"],"mappings":"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","sourcesContent":["define('bridalapp/class',[], function(){\r\n\t/**\r\n\t * Class([name] [, parent], object [, object] [, object])\r\n\t *\r\n\t * Creates a new class with the given name, parent and methods.\r\n\t *\r\n\t * name    String, Optional. The name of the new class. \r\n\t *         If not specified the new class will be anonymous.\r\n\t * parent  Class object, optional. The parent class for the new class.\r\n\t * object  Object, Required. One or more objects containing the methods \r\n\t *         and fields to add to the new class.\r\n\t */\r\n\tfunction Class() {\r\n\t\tvar name = '', parent = null, args = arrayify(arguments);\r\n\t\tif (typeof args[0] === 'string' || args[0] instanceof String) {\r\n\t\t\tname = args.shift();\r\n\t\t}\r\n\t\tif (typeof args[0] === 'function') {\r\n\t\t\tparent = args.shift();\r\n\t\t}\r\n\t\tvar classname = name || 'klass';\r\n\t\teval('var klass = function ' + classname + '() {this.initialize.apply(this, arguments);}'); // jshint ignore:line\r\n\t\tklass.classname = classname;\r\n\t\tklass.superclass = parent;\r\n\t\tklass.subclasses = [];\r\n\r\n\t\tif (parent) {\r\n\t\t\tvar subclass = function() { };\r\n\t\t\tsubclass.prototype = parent.prototype;\r\n\t\t\tklass.prototype = new subclass();\r\n\t\t\tparent.subclasses.push(klass);\r\n\t\t}\r\n\r\n\t\tfor (var i=0, len=args.length; i<len; i++) {\r\n\t\t\taddMethods(klass, args[i]);\r\n\t\t}\r\n\t\tif (!klass.prototype.initialize) {\r\n\t\t\tklass.prototype.initialize = function() { };\r\n\t\t}\r\n\t\tklass.prototype.constructor = klass;\r\n\t\treturn klass;\r\n\t}\r\n\r\n\tClass.subclass = function Class_subclass(klass, name) {\r\n\t\tif (!klass) {return;}\r\n\t\tif (klass.classname === name) {return klass;}\r\n\t\tfor (var i=0, sub; sub=klass.subclasses[i]; i++) {\r\n\t\t\tif (sub.classname === name) {return sub;}\r\n\t\t\tvar subsub = Class.subclass(sub, name);\r\n\t\t\tif (subsub) {return subsub;}\r\n\t\t}\r\n\t};\r\n\r\n\tfunction argumentNames(fn) {\r\n\t\tvar i, len, names = fn.toString().match(/^[\\s\\(]*function[^(]*\\((.*?)\\)/)[1].split(',');\r\n\t\tfor (i=0, len=names.length; i<len; i++) {\r\n\t\t\tnames[i] = names[i].replace(/^\\s+/, '').replace(/\\s+$/, '');\r\n\t\t}\r\n\t\treturn len === 1 && !names[0] ? [] : names;\r\n\t}\r\n\r\n\tfunction arrayify(it) {\r\n\t\tif (!it) {return [];}\r\n\t\tif ('toArray' in Object(it)) {return it.toArray();}\r\n\t\tvar len = it.length || 0, results = new Array(len);\r\n\t\twhile (len--) {results[len] = it[len];}\r\n\t\treturn results;\r\n\t}\r\n\r\n\tfunction bind(func) {\r\n\t\tif (arguments.length < 3 && arguments[1] === undefined) {return func;}\r\n\t\tvar args = arrayify(arguments), obj = args.splice(0, 2)[1];\r\n\t\treturn function() {\r\n\t\t\treturn func.apply(obj, args.concat(arrayify(arguments)));\r\n\t\t};\r\n\t}\r\n\r\n\tfunction wrap(func, wrapper) {\r\n\t\treturn function() {\r\n\t\t\treturn wrapper.apply(this, [bind(func, this)].concat(arrayify(arguments)));\r\n\t\t};\r\n\t}\r\n\r\n\tfunction addMethods(klass, src) {\r\n\t\tfunction keys(obj) {\r\n\t\t\tvar results = [];\r\n\t\t\tfor (var key in obj) {\r\n\t\t\t\tresults.push(key);\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t}\r\n\r\n\t\tvar ancestor = klass.superclass && klass.superclass.prototype, props = keys(src);\r\n\r\n\t\tfor (var i=0, key; key=props[i]; i++) {\r\n\t\t\tvar val = src[key];\r\n\t\t\tif (ancestor && (typeof val === 'function')) {\r\n\t\t\t\tvar argNames = argumentNames(val);\r\n\t\t\t\tif ((argNames.length > 0) && (argNames[0] === '$super')) {\r\n\t\t\t\t\tvar method = val;\r\n\t\t\t\t\tval = wrap((function(m) {\r\n\t\t\t\t\t\treturn function() {\r\n\t\t\t\t\t\t\treturn ancestor[m].apply(this, arguments); \r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t})(key), method); // jshint ignore:line\r\n\t\t\t\t\tval.valueOf = bind(method.valueOf, method);\r\n\t\t\t\t\tval.toString = bind(method.toString, method);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tklass.prototype[key] = val;\r\n\t\t}\r\n\t}\r\n\r\n\treturn Class;\r\n});\r\n\n","define('bridalapp/datastore',['bridalapp/class'], function (Class) {\r\n\t'use strict';\r\n\t\r\n\t/**\r\n\t * 'Abstract' base class for datastores.\r\n\t * \r\n\t * <p>Interaction with the datastore happens through four methods:</p>\r\n\t * <dl>\r\n\t *   <dt><code>Promise <b>load</b>(criteria, pageSize, pageIndex)</code></dt>\r\n\t *   <dd>Loads items from the store that match the given <code>criteria</code> (if any), \r\n\t *       paging the results if so desired.</dd>\r\n\t *   <dt><code>Promise <b>count</b>(criteria)</code></dt>\r\n\t *   <dd>Counts the items that match the given <code>criteria</code> (if any). This count\r\n\t *       can be used to calculate the <code>pageIndex</code> parameters when using paging.</dd>\r\n\t *   <dt><code>Promise <b>save</b>(items)</code></dt>\r\n\t *   <dd>Adds new items to the store, or updates existing items.</dd>\r\n\t *   <dt><code>Promise <b>delete</b>(items)</code></dt>\r\n\t *   <dd>Permanently deletes items from the store.</dd>\r\n\t * </ul>\r\n\t * <p>All three methods return a <code>Promise</code> that resolves to an \r\n\t * 'immutable' array(-like) with the fetched, changed or deleted items in it.</p>\r\n\t * \r\n\t * <p>Furthermore, the store can be observed for changes by attaching a listener\r\n\t * to the <code>change</code> event using the <code>on</code> method:</p>\r\n\t * <code><pre>\r\n\t * myDataStore.on('change', function() {\r\n\t *   // The store has changed. \r\n\t * });\r\n\t * </pre></code>\r\n\t * <p>The listener(s) can be removed again using the <code>off</code> method:</p>\r\n\t * <code><pre>\r\n\t * myDataStore.off('change', myListener); // removes myListener from change event\r\n\t * myDataStore.off('change'); // removes all listeners from change event\r\n\t * </pre></code>\r\n\t * \r\n\t */\r\n\tvar DataStore = Class('DataStore', {\r\n\t\t\r\n\t\tinitialize: function DataStore_initialize(name, url, cfg) {\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.url = url || ''; // storetype://path/to/repository/store\r\n\t\t\tthis.cfg = cfg || {};\r\n\t\t\tthis.cfg.listeners = this.cfg.listeners || {};\r\n\t\t\tthis.cfg.throttle = this.cfg.throttle || {};\r\n\t\t},\r\n\t\t\r\n\t\ton: function DataStore_on(event, listener) {\r\n\t\t\tthis.cfg.listeners[event] = this.cfg.listeners[event] || [];\r\n\t\t\tthis.cfg.listeners[event].push(listener);\r\n\t\t},\r\n\r\n\t\ttrigger: function DataStore_trigger(event) {\r\n\t\t\tvar me = this, cfg = me.cfg, listeners = cfg.listeners[event];\r\n\t\t\tif (listeners) {\r\n\t\t\t\tif (! cfg.throttle[event]) {\r\n\t\t\t\t\tcfg.throttle[event] = {\r\n\t\t\t\t\t\ttriggered: Date.now()\r\n\t\t\t\t\t};\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tvar throttle = cfg.throttle[event];\r\n\t\t\t\tif (throttle.timeout &&\t(Date.now() < throttle.triggered + 250)) {\r\n\t\t\t\t\tclearTimeout(throttle.timeout);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthrottle.triggered = Date.now();\r\n\t\t\t\t}\r\n\t\t\t\tthrottle.timeout = setTimeout(function(){\r\n\t\t\t\t\tfor (var i=0,listener; listener=listeners[i]; i++) {\r\n\t\t\t\t\t\tlistener.call(me);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthrottle.timeout = null;\r\n\t\t\t\t}, 10);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\toff: function DataStore_off(event, listener) {\r\n\t\t\tif (this.cfg.listeners[event]) {\r\n\t\t\t\tif (listener) {\r\n\t\t\t\t\tfor (var i=this.cfg.listeners[event].length-1; i>=0; i--) {\r\n\t\t\t\t\t\tif (this.cfg.listeners[event][i] === listener) {\r\n\t\t\t\t\t\t\treturn this.cfg.listeners[event].splice(i, 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar results = this.cfg.listeners[event];\r\n\t\t\t\t\tdelete this.cfg.listeners[event];\r\n\t\t\t\t\treturn results;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n//      ABSTRACT-------------------------------------------------------------------------------------------\r\n//\t\t                    'abstract' methods each datastore should have.\r\n//      ---------------------------------------------------------------------------------------------------\r\n\r\n\t\t/**\r\n\t\t * Loads all items from this store matching the given <code>criteria</code>.\r\n\t\t * \r\n\t\t * <p>This method returns a <code>Promise</code> that resolves to an array(-like) that should be\r\n\t\t * treated as immutable. To mutate the store, use <code>save</code> and <code>delete</code>.</p>\r\n\t\t * \r\n\t\t * @param criteria Criteria to match on. Optional. Object.\r\n\t\t * @param pageSize Limits the number of results to fetch. Optional. Number.\r\n\t\t * @param pageIndex Indicates which results to fetch. Optional. Only applies when \r\n\t\t *        <code>pageSize &gt; 0</code>. Number. \r\n\t\t * \r\n\t\t * @return A <code>Promise<code> that resolves to an 'immutable' array of items, \r\n\t\t *         possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tload: function DataStore_load(criteria, pageSize, pageIndex) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve([]);\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Counts the items matching the given <code>criteria</code>.\r\n\t\t * \r\n\t\t * <p>This method returns a <code>Promise</code> that resolves to the number of items that match\r\n\t\t * the given <code>criteria</code>, or to the total number of items if no <code>criteria</code> \r\n\t\t * were given. Using this number (which will be typically obtained with an efficient operation\r\n\t\t * such as <code>SELECT COUNT(..)</code>) you can calculate the number of pages for a certain\r\n\t\t * <code>pageSize</code> and thus determine the valid range for the <code>pageIndex</code>\r\n\t\t * parameter of the <code>load</code> operation.</p>\r\n\t\t * \r\n\t\t * @param criteria Criteria to match on. Optional. Object.\r\n\t\t * \r\n\t\t * @return A <code>Promise<code> that resolves to an 'immutable' array of items, \r\n\t\t *         possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tcount: function DataStore_count(criteria) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(0);\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Saves the given <code>item</code>(s).\r\n\t\t * \r\n\t\t * <p>Returns a <code>Promise</code> that resolves to an 'immutable' array(-like) with the added \r\n\t\t * or changed items. These items may have changes compared with the given items (such as last \r\n\t\t * modified date, version etc) so the originals are stale after this method completes.</p> \r\n\t\t * \r\n\t\t * <p>The argument can be an instance of <code>Persistent</code> or an array(-like) of instances \r\n\t\t * of <code>Persistent.</code>. Multiple arguments can be given. These are all ways to save \r\n\t\t * three persistent objects <code>a</code>, <code>b</code> and <code>c</code>:</p>\r\n\t\t * \r\n\t\t * <code><pre>\r\n\t\t * myDataStore.save(a);\r\n\t\t * myDataStore.save(b);\r\n\t\t * myDataStore.save(c);\r\n\t\t * // or\r\n\t\t * myDataStore.save(a, b, c);\r\n\t\t * // or\r\n\t\t * myDataStore.save([a,b,c]);\r\n\t\t * // or\r\n\t\t * myDataStore.save(a, [b,c]);\r\n\t\t * // etc...\r\n\t\t * </pre></code>\r\n\t\t * \r\n\t\t * <p>If we need to wait for the result of the operation, we can do so like this:</p>\r\n\t\t * \r\n\t\t * <code><pre>\r\n\t\t * myDataStore.save(myItems).then(function(results){\r\n\t\t *    // Hooray! The items are saved!\r\n\t\t *    for (var i=0, item; item=results[i]; i++) { \r\n\t\t *       // do something kick-ass with this item\r\n\t\t *       alert('Yeah! ' + item + ' is saved!'); \r\n\t\t *    }\r\n\t\t * }).catch(function(e){\r\n\t\t *    // Oh no!! Something went wrong!\r\n\t\t *    alert('There was an error: ' + e);\r\n\t\t * });\r\n\t\t * </pre></code>\r\n\t\t * \r\n\t\t * \r\n\t\t * @param  item Either a single persistent item or an array(-like) of persistent items. \r\n\t\t * @return A <code>Promise</code> that resolves to an 'immutable' array of items that were added \r\n\t\t *         or changed. Possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tsave: function DataStore_save(item) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(item.length === undefined ? [item] : item);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Permanently deletes the given <code>item</code>s.\r\n\t\t * \r\n\t\t * <p>Returns a <code>Promise</code> that yields the removed items in an array(-like). \r\n\t\t * The returned array(-like) should be treated as immutable.</p>\r\n\t\t * \r\n\t\t * <p>The argument can be an instance of Persistent or an array(-like) of instances of Persistent. \r\n\t\t * Just like with <code>save()</code>, multiple arguments can be given.</p>\r\n\t\t * \r\n\t\t * @param  item Either a single persistent item or an array(-like) of persistent items. \r\n\t\t * @return An 'immutable' array of items that were removed. Possibly empty but never <code>null</code>.\r\n\t\t */\r\n\t\tdelete: function DataStore_delete(item) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve('length' in item ? item : [item]);\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n//      /ABSTRACT------------------------------------------------------------------------------------------\r\n\t\t\r\n\t\ttoString: function DataStore_toString() {\r\n\t\t\treturn '[Object ' + this.constructor.classname + ' \\'' + this.name + '\\' {url: \\'' + this.url + '\\'}]';\r\n\t\t}\r\n\t});\r\n\r\n\t/** Registry of datastore factories by type. */\r\n\tDataStore.typeFactories = {};\r\n\t\r\n\t/** Registers the datastore <code>factory</code> as 'protocol handler' for the given <code>type</code>. */\r\n\tDataStore.registerType = function DataStore_registerType(type, factory) {\r\n\t\tif (! DataStore.typeFactories[type]) {\r\n\t\t\tDataStore.typeFactories[type] = factory;\r\n\t\t}\r\n\t};\r\n\t\r\n\t/** Creates a new datastore from the given <code>type</code>. */\r\n\tDataStore.fromType = function DataStore_fromType(name, type, url, cfg) {\r\n\t\treturn DataStore.typeFactories[type](name, url, cfg);\r\n\t};\r\n\t\r\n\t/** Creates a new datastore from the given <code>url</code>. */\r\n\tDataStore.fromUrl = function DataStore_fromUrl(name, url, cfg) {\r\n\t\tif (! url) {return null;}\r\n\t\tvar idx = url.indexOf('://'),\r\n\t\t\ts = url.substring(0, idx), \r\n\t\t\ttype = s === 'https' ? 'http' : (s || 'http');\r\n\t\treturn DataStore.fromType(name, type, url, cfg);\r\n\t};\r\n\t\r\n\treturn DataStore;\r\n});\r\n\n","define('bridalapp/synchabledatastore',['suid', 'bridalapp/class', 'bridalapp/datastore'], function (Suid, Class, DataStore) {\r\n\t'use strict';\r\n\t\r\n\t/**\r\n\t * 'Abstract' base class for local datastores that can synched with some backend.\r\n\t * \r\n\t * <p>The main API of synchable datastores is:</p>\r\n\t * \r\n\t * <dl>\r\n\t *   <dt><code>Boolean <b>lookSynched</b>()</code></dt>\r\n\t *   <dd>Indicates whether the datastore looks synched (from this end).</dd>\r\n\t *   <dt><code>Promise <b>synch</b>()</code></dt>\r\n\t *   <dd>Brings this datastore back into synch.</dd>\r\n\t *   <dt><code>Boolean <b>isSynching</b>()</code></dt>\r\n\t *   <dd>Indicates whether this datastore is currently busy synching.</dd>\r\n\t *   <dt><code>Array(-like) <b>items</b>()</code></dt>\r\n\t *   <dd>Returns an 'immutable' array(-like) that represents a live view of the items \r\n\t *       maintained in this store.</dd>\r\n\t *   <dt><code>Array <b>createdItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that have been added to the store since the last synch.</dd>\r\n\t *   <dt><code>Array <b>updatedItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that have been updated since the last synch.</dd>\r\n\t *   <dt><code>Array <b>deletedItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that have been deleted from the store since the last synch.</dd>\r\n\t *   <dt><code>Array <b>staleItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that could not be saved during the last synch because they went stale.</dd>\r\n\t *   <dt><code>Array <b>failedItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that could not be saved during the last synch because they had errors.</dd>\r\n\t *   <dt><code>Array <b>futureItems</b>()</code></dt>\r\n\t *   <dd>'Immutable' array of items that were already updated when a synch started and were then updated again while synch was in progress.</dd>\r\n\t * </dl>\r\n\t * \r\n\t * <p>synchable datastores are assumed to have fast access to (a cache of) all data they maintain.\r\n\t * As such they provide a synchronous API for accessing and mutating the data in the datastore \r\n\t * that is easier to work with than the default asynchronous <code>load</code>, <code>count</code>, \r\n\t * <code>save</code> and <code>delete</code> methods:</p>\r\n\t * \r\n\t * <dl>\r\n\t *   <dt><code>Array get(criteria, pageSize, pageIndex)</code></dt>\r\n\t *   <dd>Synchronous equivalent of <code>load</code>.</dd>\r\n\t *   <dt><code>Number len(criteria)</code></dt>\r\n\t *   <dd>Synchronous equivalent of <code>count</code>.</dd>\r\n\t *   <dt><code>Array set(item)</code></dt>\r\n\t *   <dd>Synchronous equivalent of <code>save</code>.</dd>\r\n\t *   <dt><code>Array del(item)</code></dt>\r\n\t *   <dd>Synchronous equivalent of <code>delete</code>.</dd>\r\n\t * </dl>\r\n\t * \r\n\t * <p>The synchronous methods operate on the locally cached data. As such, the\r\n\t * methods <code>set</code> and <code>del</code> will usually make the datastore\r\n\t * <i>out of synch</i>. You can check whether the datastore still looks in synch\r\n\t * with <code>looksSynched</code> and bring it back in synch with <code>synch</code>.</p>\r\n\t * \r\n\t * <p>Unlike their asynchonous counterparts, the synchronous methods <code>set</code>\r\n\t * and <code>del</code> return the items unchanged, so essentially they can be\r\n\t * discarded.</p>\r\n\t */\r\n\tvar SynchableDataStore = Class('SynchableDataStore', DataStore, {\r\n\t\t\r\n\t\tinitialize: function SynchableDataStore_initialize($super, name, url, cfg) {\r\n\t\t\t$super(name, url, cfg);\r\n\t\t},\r\n\t\t\r\n\t\t/** \r\n\t\t * Synchronous equivalent of <code>load</code>.\r\n\t\t * \r\n\t\t * <p>No remote request will actually be fired. The filtering based on the\r\n\t\t * given <code>criteria</code> and the paging both happen client-side and\r\n\t\t * will be fast as long as the dataset is not too large.</p>\r\n\t\t */\r\n\t\tget: function SynchableDataStore_get(criteria, pageSize, pageIndex, clone) {\r\n\t\t\tvar items = clone ? Persistent.clone(this.items()) : this.items();\r\n\t\t\treturn Persistent.page(Persistent.matches(items, criteria), pageSize, pageIndex);\r\n\t\t},\r\n\r\n\t\t/** \r\n\t\t * Synchronous equivalent of <code>count</code>.\r\n\t\t *  \r\n\t\t * <p>No remote request will actually be fired. This method just calls\r\n\t\t * <code>get</code> with the given <code>criteria</code> and returns\r\n\t\t * the number of results it got.</p>\r\n\t\t */\r\n\t\tlen: function SynchableDataStore_len(criteria) {\r\n\t\t\treturn this.get(criteria).length;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Indicates whether this datastore looks synchronized (from this end). \r\n\t\t * \r\n\t\t * <p>This method will return <code>false</code> if there are any outstanding changes, \r\n\t\t * but this method returning <code>true</code> does not guarantee anything as it is \r\n\t\t * impossible to determine whether something was changed on the remote side without\r\n\t\t * actually making a request.\r\n\t\t */\r\n\t\tlooksSynched: function SynchableDataStore_looksSynched() {\r\n\t\t\t// if lastSynched == Date(0) (epoch) it means we are not synched\r\n\t\t\t// if there are any items in any of the lists it means we are not in synch\r\n\t\t\treturn (this.lastSynched().getTime() !== 0) && \r\n\t\t\t\t\t(! (this.createdItems().length || this.updatedItems().length || this.deletedItems().length));\r\n\t\t},\r\n\t\t\r\n\r\n//\t\tABSTRACT-------------------------------------------------------------------------\r\n//\t\t             'abstract' methods each synchable datastore should have\r\n//\t\t---------------------------------------------------------------------------------\r\n\t\t/** \r\n\t\t * Brings this datastore back into synch.\r\n\t\t * \r\n\t\t * <p>Returns a promise that resolves on synch complete or rejects on\r\n\t\t * synch failure. The arrays returned by <code>staleItems</code> and \r\n\t\t * <code>failedItems</code> will be updated with items that could not\r\n\t\t * be saved because they had been changed on the remote server in the\r\n\t\t * meantime, or that gave (integrity constraint) validation errors,\r\n\t\t * respectively.</p> \r\n\t\t */\r\n\t\tsynch: function SynchableDataStore_synch() {return new Promise(function(resolve){resolve();})},\r\n\r\n\t\t/** Indicates whether this datastore is currently busy synching. */\r\n\t\tisSynching: function SynchableDataStore_isSynching() {return false;},\r\n\t\t\r\n\t\t/** Gets or sets the (device) date time this datastore was last synched. */\r\n\t\tlastSynched: function SynchableDataStore_lastSynched(newDate) {return newDate || new Date();},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns an 'immutable' array that represents a live view of the items\r\n\t\t * maintained in this store. \r\n\t\t * \r\n\t\t * <p>The result of this method can be used for observing/monitoring the\r\n\t\t * data set. DO NOT MUTATE THIS ARRAY!.</p>\r\n\t\t */\r\n\t\titems: function SynchableDataStore_items() {},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that have been added to the store since the last synch. */\r\n\t\tcreatedItems: function SynchableDataStore_createdItems() {return [];},\r\n\t\t\r\n\t\t/** 'Immutable' array of the original versions of items that have been updated since the last synch. */\r\n\t\tupdatedItems: function SynchableDataStore_updatedItems() {return [];},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that have been deleted since the last synch. */\r\n\t\tdeletedItems: function SynchableDataStore_deletedItems() {return [];},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that could not be saved during the last synch because they went stale. */\r\n\t\tstaleItems: function SynchableDataStore_staleItems() {return [];},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that could not be saved during the last synch because they had errors. */\r\n\t\tfailedItems: function SynchableDataStore_failedItems() {return [];},\r\n\t\t\r\n\t\t/** \r\n\t\t * 'Immutable' array of items that were already updated when a synch started and were then updated again while synch was in progress.\r\n\t\t *  These items are effectively stale, but because the user edited his own items, we can safely assume\r\n\t\t *  he wishes to overwrite the remote version with the item that is in this list.\r\n\t\t */\r\n\t\tfutureItems: function SynchableDataStore_failedItems() {return [];},\r\n\r\n\t\t/** \r\n\t\t * Synchronous equivalent of <code>save</code>.\r\n\t\t * \r\n\t\t * <p>The arrays returned by <code>updatedItems</code>, <code>createdItems</code>\r\n\t\t * and <code>removedItems</code> will be updated to reflect the changes made\r\n\t\t * to the datastore since the last synch.</p>\r\n\t\t */\r\n\t\tset: function SynchableDataStore_set(item) {return item},\r\n\t\t\r\n\t\t/**\r\n\t\t * Synchronous equivalent of <code>delete</code>.\r\n\t\t *  \r\n\t\t * <p>The arrays returned by <code>updatedItems</code>, <code>createdItems</code>\r\n\t\t * and <code>removedItems</code> will be updated to reflect the changes made\r\n\t\t * to the datastore since the last synch.</p>\r\n\t\t */\r\n\t\tdel: function SynchableDataStore_del(item) {return item},\r\n//\t\t/ABSTRACT------------------------------------------------------------------------\r\n\t\t\r\n\t\ttoString: function SynchableDataStore_toString($super) {\r\n\t\t\tvar s = $super();\r\n\t\t\ts = s.substring(0, s.length - 2);\r\n\t\t\treturn '[Object ' + this.constructor.classname + ' \\'' + this.name + '\\' {' + \r\n\t\t\t\t\t'url: \\'' + this.url + '\\', ' + \r\n\t\t\t\t\t'lastSynched:' + this.lastSynched() + ', ' + \r\n\t\t\t\t\t'items:' + this.items().length + ', ' + \r\n\t\t\t\t\t'created:' + this.createdItems().length + ', ' + \r\n\t\t\t\t\t'updated:' + this.updatedItems().length + ', ' + \r\n\t\t\t\t\t'deleted:' + this.deletedItems().length + ', ' + \r\n\t\t\t\t\t'stale:' + this.staleItems().length + ', ' +\r\n\t\t\t\t\t'failed:' + this.failedItems().length + '}]';\r\n\t\t}\r\n\t});\r\n\t\r\n\t\r\n\treturn SynchableDataStore;\r\n});\r\n\n","define('bridalapp/persistent',['bridalapp/class', 'suid'], function (Class, Suid) {\r\n\tvar Persistent = Class('Persistent', {\r\n\t\tinitialize: function Persistent_initialize(obj) {\r\n\t\t\tthis.id = (obj && obj.id) || Suid(0);\r\n\t\t\tthis.type = this.constructor.classname;\r\n\t\t\tthis.version = obj && (obj.version !== undefined) ? obj.version : null;\r\n\t\t},\r\n\t\t\r\n\t\tequals: function Persistent_equals(other){\r\n\t\t\treturn other && (\r\n\t\t\t\t\t(other instanceof Persistent && other.id.value === this.id.value) ||\r\n\t\t\t\t\t(other instanceof Suid && other.value === this.id.value) || \r\n\t\t\t\t\t(other == this.id.value) \r\n\t\t\t) ;\r\n\t\t},\r\n\t\t\r\n\t\ttoString: function Persistent_toString() {\r\n\t\t\treturn '[Object ' + this.type + ' ' + this.id.toString() + ' v' + this.version + ']';\r\n\t\t}\r\n\t});\r\n\t\r\n\tPersistent.revive = function Persistent_revive(key, value) {\r\n\t\tvar t = value && typeof value === 'object' && typeof value.type === 'string' && value.type,\r\n\t\t\tconstructor = Class.subclass(Persistent, t);\r\n\t\treturn constructor ? new constructor(value) : Suid.revive(key, value);\r\n\t}; \r\n\t\r\n\tPersistent.fromJSON = function Persistent_fromJSON(json) {\r\n\t\treturn JSON.parse(json, Persistent.revive);\r\n\t};\r\n\t\r\n\tPersistent.persistent = function Persistent_persistent(arg) {\r\n\t\tif (arguments.length === 1) {return arg instanceof Persistent && arg.version !== null;}\r\n\t\tvar results = [];\r\n\t\tfor (var i=0; arg=arguments[i]; i++) {\r\n\t\t\tif (Persistent.persistent(arg)) {results.push(arg);}\r\n\t\t\telse if ('length' in arg){\r\n\t\t\t\tfor (var j=0, item; item=arg[j]; j++) {\r\n\t\t\t\t\tif (Persistent.persistent(item)) {results.push(item);}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.equals = function Persistent_static_equals(one, other, comparator) {\r\n\t\treturn (one == other ||\r\n\t\t\t\t(comparator && comparator(one, other) === 0) ||\r\n\t\t\t\tone && one.equals && one.equals(other) ||\r\n\t\t\t\tother && other.equals && other.equals(one) ||\r\n\t\t\t\t(typeof one === 'object' && one && one.valueOf() == other) ||\r\n\t\t\t\t(typeof other === 'object' && other && other.valueOf() == one));\r\n\t};\r\n\t\r\n\t// returns index of given element in given list, using given comparator\r\n\tPersistent.indexOf = function Persistent_indexOf(list, element, comparator) {\r\n\t\tfor (var i=0, item; item=list[i]; i++) {\r\n\t\t\tif (Persistent.equals(item, element)) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t};\r\n\r\n\t// CRITERIA on the cheap\r\n\tPersistent.matches = function Persistent_matches(items, criteria) {\r\n\t\tvar results = Array.prototype.concat.call(items || []);\r\n\t\tif (criteria) {\r\n\t\t\tfor (var i=results.length-1; i>=0; i--) {\r\n\t\t\t\tfor (var key in criteria) {\r\n\t\t\t\t\tif (criteria.hasOwnProperty(key)) {\r\n\t\t\t\t\t\tif ((((Array.isArray && Array.isArray(criteria[key])) || (criteria[key] instanceof Array)) && (Persistent.indexOf(criteria[key], items[i][key]) === -1)) \r\n\t\t\t\t\t\t\t\t|| (! Persistent.equals(items[i][key], criteria[key]))) {\r\n\t\t\t\t\t\t\tresults.splice(i,1); \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.pluck = function Persistent_pluck(items, attr) {\r\n\t\tvar results = [];\r\n\t\tfor (var i=0,item; item=items[i]; i++) {\r\n\t\t\tif (item[attr] !== undefined) {\r\n\t\t\t\tresults.push(item[attr]); \r\n\t\t\t}\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.clone = function Persistent_clone(items) {\r\n\t\tvar results = [];\r\n\t\tif (arguments.length > 1) {return Persistent.clone(arguments);}\r\n\t\tif (! ('length' in items)) {return items instanceof Persistent && items.clone ? items.clone() : Persistent.fromJSON(JSON.stringify(items));}\r\n\t\tvar results = [];\r\n\t\tfor (var i=0, item; item=items[i]; i++) {\r\n\t\t\tresults.push(Persistent.clone(item));\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.page = function Persistent_page(results, pageSize, pageIndex) {\r\n\t\tif (pageSize) {\r\n\t\t\tvar start = (pageIndex || 0) * pageSize,\r\n\t\t\t\tend = pageIndex * (pageSize+1);\r\n\t\t\tif ((end < 0) || (end <= start) || (start > results.length)) {return [];}\r\n\t\t\treturn results.slice(Math.max(start,0), Math.min(end, results.length));\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\t\r\n\tPersistent.eachArg = function Persistent_eachArg(args, obj, fn) {\r\n\t\tif (('length' in args) && (! (args instanceof Persistent))) {\r\n\t\t\tvar results = [];\r\n\t\t\tfor (var i=0,item; item=args[i]; i++) {\r\n\t\t\t\tresults.push.apply(results, Persistent.eachArg(item, obj, fn));\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t}\r\n\t\treturn fn.call(obj, args);\r\n\t}\r\n\t\r\n\treturn Persistent;\r\n});\r\n\n","define('bridalapp/rhaboodatastore',['bridalapp/class',\r\n\t\t'bridalapp/datastore', \r\n\t\t'bridalapp/synchabledatastore', \r\n\t\t'bridalapp/persistent', \r\n\t\t'rhaboo'], \r\nfunction (Class, DataStore, SynchableDataStore, Persistent) {\r\n\t'use strict';\r\n\t\r\n\tvar RhabooDataStore = Class('RhabooDataStore', SynchableDataStore, {\r\n\r\n\t\tinitialize: function RhabooDataStore_initialize($super, name, url, cfg) {\r\n\t\t\t$super(name, url, cfg);\r\n\t\t\tif (!this.cfg.rhaboo || !this.cfg.store) { \r\n\t\t\t\tvar repoIdx = url.indexOf('://') + 3,\r\n\t\t\t\t\tstoreIdx = url.lastIndexOf('/'),\r\n\t\t\t\t\trepo = url.substring(repoIdx, storeIdx),\r\n\t\t\t\t\tstore = url.substring(storeIdx + 1);\r\n\t\t\t\tif (!this.cfg.repo) {this.cfg.repo = repo;}\r\n\t\t\t\tif (!this.cfg.store) {this.cfg.store = store;}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Loads all items from this store matching the given <code>criteria</code>.\r\n\t\t * \r\n\t\t * <p>This method returns a <code>Promise</code> that resolves to an array(-like) that should be\r\n\t\t * treated as immutable. To mutate the store, use <code>save</code> and <code>delete</code>.</p>\r\n\t\t * \r\n\t\t * @param criteria Criteria to match on. Optional. Object.\r\n\t\t * @param pageSize Limits the number of results to fetch. Optional. Number.\r\n\t\t * @param pageIndex Indicates which results to fetch. Optional. Only applies when \r\n\t\t *        <code>pageSize &gt; 0</code>. Number. \r\n\t\t * \r\n\t\t * @return A <code>Promise<code> that resolves to an 'immutable' array of items, \r\n\t\t *         possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tload: function DataStore_load(criteria, pageSize, pageIndex) {\r\n\t\t\tvar store = this;\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(this.get(criteria, pageSize, pageIndex));\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Counts the items matching the given <code>criteria</code>.\r\n\t\t * \r\n\t\t * <p>This method returns a <code>Promise</code> that resolves to the number of items that match\r\n\t\t * the given <code>criteria</code>, or to the total number of items if no <code>criteria</code> \r\n\t\t * were given. Using this number (which will be typically obtained with an efficient operation\r\n\t\t * such as <code>SELECT COUNT(..)</code>) you can calculate the number of pages for a certain\r\n\t\t * <code>pageSize</code> and thus determine the valid range for the <code>pageIndex</code>\r\n\t\t * parameter of the <code>load</code> operation.</p>\r\n\t\t * \r\n\t\t * @param criteria Criteria to match on. Optional. Object.\r\n\t\t * \r\n\t\t * @return A <code>Promise<code> that resolves to an 'immutable' array of items, \r\n\t\t *         possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tcount: function DataStore_count(criteria) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(this.len());\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Saves the given <code>item</code>(s).\r\n\t\t * \r\n\t\t * <p>Returns a <code>Promise</code> that resolves to an 'immutable' array(-like) with the added \r\n\t\t * or changed items. These items may have changes compared with the given items (such as last \r\n\t\t * modified date, version etc) so the originals are stale after this method completes.</p> \r\n\t\t * \r\n\t\t * <p>The argument can be an instance of <code>Persistent</code> or an array(-like) of instances \r\n\t\t * of <code>Persistent.</code>. Multiple arguments can be given. These are all ways to save \r\n\t\t * three persistent objects <code>a</code>, <code>b</code> and <code>c</code> (though they\r\n\t\t * differ in performance, bundling calls is quicker)</p>:\r\n\t\t * \r\n\t\t * <code><pre>\r\n\t\t * myDataStore.save(a);\r\n\t\t * myDataStore.save(b);\r\n\t\t * myDataStore.save(c);\r\n\t\t * // or\r\n\t\t * myDataStore.save(a, b, c);\r\n\t\t * // or\r\n\t\t * myDataStore.save([a,b,c]);\r\n\t\t * // or\r\n\t\t * myDataStore.save(a, [b,c]);\r\n\t\t * // etc...\r\n\t\t * </pre></code>\r\n\t\t * \r\n\t\t * <p>If we need to wait for the result of the operation, we can do so like this:</p>\r\n\t\t * \r\n\t\t * <code><pre>\r\n\t\t * myDataStore.save(myItems).then(function(results){\r\n\t\t *    // Hooray! The items are saved!\r\n\t\t *    for (var i=0, item; item=results[i]; i++) { \r\n\t\t *       // do something kick-ass with this item\r\n\t\t *       alert('Yeah! ' + item + ' is saved!'); \r\n\t\t *    }\r\n\t\t * }).catch(function(e){\r\n\t\t *    // Oh no!! Something went wrong!\r\n\t\t *    alert('There was an error: ' + e);\r\n\t\t * });\r\n\t\t * </pre></code>\r\n\t\t * \r\n\t\t * \r\n\t\t * @param  item Either a single persistent item or an array(-like) of persistent items. \r\n\t\t * @return A <code>Promise</code> that resolves to an 'immutable' array of items that were added \r\n\t\t *         or changed. Possibly empty but never <code>null</code> or <code>undefined</code>.\r\n\t\t */\r\n\t\tsave: function DataStore_save(item) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(this.set(item));\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Permanently deletes the given <code>item</code>s.\r\n\t\t * \r\n\t\t * <p>Returns a <code>Promise</code> that yields the removed items in an array(-like). \r\n\t\t * The returned array(-like) should be treated as immutable.</p>\r\n\t\t * \r\n\t\t * <p>The argument can be an instance of Persistent or an array(-like) of instances of Persistent. \r\n\t\t * Just like with <code>save()</code>, multiple arguments can be given.</p>\r\n\t\t * \r\n\t\t * @param  item Either a single persistent item or an array(-like) of persistent items. \r\n\t\t * @return An 'immutable' array of items that were removed. Possibly empty but never <code>null</code>.\r\n\t\t */\r\n\t\tdelete: function DataStore_delete(item) {\r\n\t\t\treturn new Promise(function(resolve){\r\n\t\t\t\tresolve(this.del(item));\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\tset: function RhabooDataStore_set(item) {\r\n\t\t\tvar results = Persistent.eachArg(arguments, this, function(item) {\r\n\t\t\t\tvar backup = null,\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().items, item);\r\n\t\t\t\tif (idx === -1) {this.db().items.push(item);} \r\n\t\t\t\telse {backup = this.db().items.splice(idx, 1, item)[0];}\r\n\t\t\t\t\r\n\t\t\t\t// item had been deleted previously?\r\n\t\t\t\tidx = Persistent.indexOf(this.db().deleted, item);\r\n\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t// item was deleted, then added again, so effectively it was updated.\r\n\t\t\t\t\tbackup = this.db().deleted.splice(idx, 1);\r\n\t\t\t\t}\r\n\t\t\t\tif (backup) {\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().updated, item);\r\n\t\t\t\t\tif (idx === -1) {this.db().updated.push(backup);}\r\n\t\t\t\t\telse if (this.synching) {\r\n\t\t\t\t\t\t// the synch is already in progress... meaning when we get back the saved\r\n\t\t\t\t\t\t// item our new version would appear stale... So put it in future list\r\n\t\t\t\t\t\tidx = Persistent.indexOf(this.db().future, item);\r\n\t\t\t\t\t\tif (idx === -1) {this.db().future.push(item);}\r\n\t\t\t\t\t\telse {this.db().future.splice(idx, 1, item);}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn [item];\r\n\t\t\t});\r\n\t\t\tthis.trigger('change');\r\n\t\t\treturn results;\r\n\t\t},\r\n\r\n\t\tdel: function RhabooDataStore_del(item) {\r\n\t\t\tvar results = Persistent.eachArg(arguments, this, function(item) {\r\n\t\t\t\tvar backup, idx = Persistent.indexOf(this.items(), item);\r\n\t\t\t\tif (idx !== -1) {backup = this.items().splice(idx, 1)[0];}\r\n\t\t\t\tif (Persistent.persistent(item)) {\r\n\t\t\t\t\t// if item was in updated list, remove it\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().updated, item);\r\n\t\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t\tvar removed = this.db().updated.splice(idx, 1);\r\n\t\t\t\t\t\tbackup = backup || removed;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if item was in future list, remove it\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().future, item);\r\n\t\t\t\t\tif (idx !== -1) {this.db().future.splice(idx, 1);}\r\n\t\t\t\t\t// if item was not in deleted list, add it (old version if we have it)\r\n\t\t\t\t\tidx = Persistent.indexOf(this.db().deleted, item);\r\n\t\t\t\t\tif (idx === -1) {this.db().deleted.push(backup || item);}\r\n\t\t\t\t}\r\n\t\t\t\treturn [backup || item];\r\n\t\t\t});\r\n\t\t\tthis.trigger('change');\r\n\t\t\treturn results;\r\n\t\t},\r\n\t\t\r\n\t\t/** Gets or sets the (device) date time this store was last synched. */\r\n\t\tlastSynched: function RhabooDataStore_lastSynched(date) {\r\n\t\t\tif (date) {this.db().write('lastSynched', date);}\r\n\t\t\treturn this.db().lastSynched;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns an 'immutable' array that represents a live view of the items\r\n\t\t * maintained in this store. \r\n\t\t * \r\n\t\t * <p>The result of this method can be used for observing/monitoring the\r\n\t\t * data set. DO NOT MUTATE THIS ARRAY!.</p>\r\n\t\t */\r\n\t\titems: function RhabooDataStore_items() {\r\n\t\t\treturn this.db().items;\r\n\t\t},\r\n\r\n\t\t/** List of created items is calculated dynamically based on which items are not persistent yet */\r\n\t\tcreatedItems: function RhabooDataStore_createdItems() {\r\n\t\t\tvar results = [];\r\n\t\t\tfor (var i=0, item; item=this.items()[i]; i++) {\r\n\t\t\t\tif (! Persistent.persistent(item)) {results.push(item);}\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t},\r\n\t\t\r\n\t\tupdatedItems: function RhabooDataStore_updatedItems() {\r\n\t\t\treturn this.db().updated;\r\n\t\t},\r\n\t\t\r\n\t\tdeletedItems: function RhabooDataStore_deletedItems() {\r\n\t\t\treturn this.db().deleted;\r\n\t\t},\r\n\r\n\t\tstaleItems: function RhabooDataStore_staleItems() {\r\n\t\t\treturn this.db().stale;\r\n\t\t},\r\n\t\t\r\n\t\tfailedItems: function RhabooDataStore_failedItems() {\r\n\t\t\treturn this.db().failed;\r\n\t\t},\r\n\t\t\r\n\t\tfutureItems: function RhabooDataStore_futureItems() {\r\n\t\t\treturn this.db().future;\r\n\t\t},\r\n\t\t\r\n\t\tdb: function RhabooDataStore_db() {\r\n\t\t\tif (! this.cfg.rhaboo) {\r\n\t\t\t\tthis.cfg.rhaboo = Rhaboo.persistent(this.cfg.repo);\r\n\t\t\t\tif (! this.cfg.rhaboo[this.cfg.store]) {this.cfg.rhaboo.write(this.cfg.store, {});}\r\n\t\t\t\tfor (var i=0,key; key=['items', 'updated', 'deleted', 'stale', 'failed', 'future'][i]; i++) {\r\n\t\t\t\t\tif (! this.db()[key]) {this.db().write(key, []);}\r\n\t\t\t\t}\r\n\t\t\t\tif(! this.db().lastSynched) {this.db().write('lastSynched', new Date(0));}\r\n\t\t\t}\r\n\t\t\treturn this.cfg.rhaboo[this.cfg.store];\r\n\t\t}\r\n\t});\r\n\t\r\n\tDataStore.registerType('rhaboo', function RhabooDataStoreFactory(name, url, cfg) {\r\n\t\treturn new RhabooDataStore(name, url, cfg);\r\n\t});\r\n\t\r\n\treturn RhabooDataStore;\r\n});\r\n\n","define('bridalapp/log',[], function () {\r\n\tvar METHODS = ['log','info','warn','error'],\r\n\t\tout = ('console' in this) && console.error ? console : {},\r\n\t\tcon = {}, // save backups of native console functions here\r\n\t\tnul = {}, // keep empty console functions here\r\n\t\ti, key;\r\n\r\n\tfor (i=0; key=METHODS[i]; i++) {\r\n\t\tnul[key] = function(){}\r\n\t\tcon[key] = out[key] || nul[key];\r\n\t}\r\n\r\n\tfunction log() {\r\n\t\treturn out;\r\n\t}\r\n\r\n\tlog.level = function log_level(lvl) {\r\n\t\tif ((lvl !== undefined) && (lvl >= 0) && (lvl <= 4) && (lvl !== logLevel)) {\r\n\t\t\tlogLevel = lvl;\r\n\t\t\t// modify the console methods: \r\n\t\t\t// those which are below the current log level get replaced by empty functions\r\n\t\t\tfor (var i=0,fn; fn=METHODS[i]; i++) {\r\n\t\t\t\tout[fn] = i >= lvl ? con[fn] : nul[fn];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn logLevel;\r\n\t};\r\n\r\n\tlog.level.DEBUG = 0;\r\n\tlog.level.INFO = 1;\r\n\tlog.level.WARN = 2;\r\n\tlog.level.ERROR = 3;\r\n\tlog.level.NONE = 4;\r\n\t\r\n\tvar logLevel = log.level.DEBUG;\r\n\r\n\treturn log;\r\n});\r\n\n","define('bridalapp/restdatastore',['bridalapp/class', \r\n\t\t'jquery', \r\n\t\t'bridalapp/log', \r\n\t\t'bridalapp/persistent', \r\n\t\t'bridalapp/datastore'], \r\nfunction (Class, $, log, Persistent, DataStore) {\r\n\t'use strict';\r\n\t\r\n\tvar RestDataStore = Class('RestDataStore', DataStore, {\r\n\t\t\r\n\t\tinitialize: function RestDataStore_initialize($super, name, url, cfg) {\r\n\t\t\t$super(name, url, cfg);\r\n\t\t\tthis.cfg.retryCount = this.cfg.retryCount || 0;\r\n\t\t\tthis.cfg.retryWaitTime = this.cfg.retryWaitTime || 2000;\r\n\t\t\tthis.cfg.timeout = this.cfg.timeout || 10000;\r\n\t\t\tif (this.cfg.supportsSynch === undefined) {this.cfg.supportsSynch = false}\r\n\t\t},\r\n\r\n\t\tload: function RestDataStore_load(criteria, pageSize, pageIndex) {\r\n\t\t\t// TODO add criteria and paging parameters to the url\r\n\t\t\treturn this.remoteRequest('GET', this.url, {criteria: criteria, pageSize: pageSize, pageIndex: pageIndex});\r\n\t\t},\r\n\r\n\t\tcount: function RestDataStore_count(criteria) {\r\n\t\t\t// TODO do the right thing and implement a count query\r\n\t\t\t// needs work on the server side as well and not needed yet\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tthis.remoteRequest('GET', this.url, {criteria: criteria}).then(function(items){\r\n\t\t\t\t\tresolve(items.length);\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t});  \r\n\t\t},\r\n\r\n\t\tsave: function RestDataStore_save(items) {\r\n\t\t\tvar all = Persistent.eachArg(items, this, function(item){return [item];});\r\n\t\t\treturn this.remoteRequest('POST', this.url + '/save', all);\r\n\t\t},\r\n\r\n\t\tdelete: function RestDataStore_delete(items) {\r\n\t\t\tvar all = Persistent.eachArg(items, this, function(item){return [item];});\r\n\t\t\treturn this.remoteRequest('DELETE', this.url, all);\r\n\t\t},\r\n\r\n\t\tsynch: function RestDataStore_synch(synchRequest) {\r\n\t\t\treturn this.remoteRequest('POST', this.url + '/synch', synchRequest);\r\n\t\t},\r\n\r\n\t\tremoteRequest: function RestDataStore_remoteRequest(method, url, data) {\r\n\t\t\treturn (function(method, url, data, timeout, retries, retryWait){\r\n\t\t\t\tvar THROTTLE = 5000,\r\n\t\t\t\t\tstarted = Date.now(),\r\n\t\t\t\t\tstore = this;\r\n\t\t\t\t\r\n\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\tif ((method === 'GET') && data) {\r\n\t\t\t\t\t\tvar hashIdx = url.indexOf('#'),   \r\n\t\t\t\t\t\t\thash = hashIdx !== -1 ? url.substring(hashIdx) : '',\r\n\t\t\t\t\t\t\tqsIdx = url.indexOf('?'),\r\n\t\t\t\t\t\t\tqs = qsIdx !== -1 ? url.substring(qsIdx) : '';\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (data.criteria) {\r\n\t\t\t\t\t\t\tfor (var key in data.criteria) {\r\n\t\t\t\t\t\t\t\tif (data.criteria.hasOwnProperty(key)) {\r\n\t\t\t\t\t\t\t\t\tqs += (qs ? '&' : '') + encodeURIComponent(key) + '=' \r\n\t\t\t\t\t\t\t\t\t\t\t+ encodeURIComponent(data.criteria[key].toString());\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (data.pageSize) {\r\n\t\t\t\t\t\t\tqs += (qs ? '&' : '') + 'pg=' + data.pageIndex + '&pgsz=' + data.pageSize;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\turl = url + qs + hash;\r\n\t\t\t\t\t\tdata = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t\trequest(method, url, data, error, resolve, reject);\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tfunction info(data) {\r\n\t\t\t\t\tvar info = '';\r\n\t\t\t\t\tif (data) {\r\n\t\t\t\t\t\tif (data.length) {info = '(' + data.length + ' items)';}\r\n\t\t\t\t\t\telse if (data.createdItems) {\r\n\t\t\t\t\t\t\tvar parts = [];\r\n\t\t\t\t\t\t\tif (data.createdItems.length) {parts.push(data.createdItems.length + ' created');} \r\n\t\t\t\t\t\t\tif (data.updatedItems.length) {parts.push(data.updatedItems.length + ' updated');}\r\n\t\t\t\t\t\t\tif (data.deletedItems && data.deletedItems.length) {parts.push(data.deletedItems.length + ' deleted');}\r\n\t\t\t\t\t\t\tif (data.deletedIds && data.deletedIds.length) {parts.push(data.deletedIds.length + ' deleted');}\r\n\t\t\t\t\t\t\tif (parts.length) {info = '(' + parts.join(', ') + ')';}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn info;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfunction request(method, url, data, errorHandler, resolve, reject) {\r\n\t\t\t\t\tvar pre = '';\r\n\t\t\t\t\tfor (var i=0; i<6-method.length; i++) {pre += ' ';}\r\n\t\t\t\t\tlog().log(' -> ' + pre + method + ' ' + url + ' ' + info(data));\r\n\t\t\t\t\t\r\n\t\t\t\t\t$.ajax(url, {\r\n\t\t\t\t\t\tmethod: method,\r\n\t\t\t\t\t\tcontentType: 'application/json',\r\n\t\t\t\t\t\tprocessData: false,\r\n\t\t\t\t\t\tdata: data && JSON.stringify(data),\r\n\t\t\t\t\t\ttimeout: timeout\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.done(function(data, statusText, jqXHR){\r\n\t\t\t\t\t\tif (jqXHR.responseText.indexOf('j_security_check') !== -1) {\r\n\t\t\t\t\t\t\t// login challenge from server, session expired\r\n\t\t\t\t\t\t\tlog().info('401 ' + pre + method + ' ' + url + ' ' + info(data) + ' (LOGIN CHALLENGE)');\r\n\t\t\t\t\t\t\terrorHandler(jqXHR, method, url, data, resolve, reject);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tlog().info('200 ' + pre + method + ' ' + url + ' ' + info(data) + ' (OK)');\r\n\t\t\t\t\t\t\tretries = 0;\r\n\t\t\t\t\t\t\tresolve(Persistent.fromJSON(jqXHR.responseText));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.fail(function(jqXHR, textStatus, errorThrown) {\r\n\t\t\t\t\t\tjqXHR.statusText = errorThrown || textStatus; \r\n\t\t\t\t\t\tlog().warn(jqXHR.status + ' ' + pre + method + ' ' + url + ' ' + info(data) + ' (' + jqXHR.statusText + ')');\r\n\t\t\t\t\t\terrorHandler(jqXHR, method, url, data, resolve, reject);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfunction error(jqXHR, method, url, data, resolve, reject) {\r\n\t\t\t\t\t// status code 5xx ? possibly recoverable.\r\n\t\t\t\t\tvar statusText = jqXHR.statusText;\r\n\t\t\t\t\tswitch(status) {\r\n\t\t\t\t\t\tcase 500: // Internal server error\r\n\t\t\t\t\t\tcase 502: // Bad Gateway\r\n\t\t\t\t\t\tcase 503: // Service unavailable\r\n\t\t\t\t\t\tcase 504: // Gateway Timeout\r\n\t\t\t\t\t\t\tif (retries > 0) {\r\n\t\t\t\t\t\t\t\tretry(jqXHR, method, url, data, errorHandler, resolve, reject);\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tcase 200: // Happens in case of server login challenge when unauthorized\r\n\t\t\t\t\t\t\tif (jqXHR.status == 200) {\r\n\t\t\t\t\t\t\t\t// TODO handle this\r\n\t\t\t\t\t\t\t\tstatusText = 'Session expired.';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdefault: // unrecoverable or too many tries. give up \r\n\t\t\t\t\t\t\tretries = 0;\r\n\t\t\t\t\t\t\tvar err = new Error(jqXHR.status + ' ' + statusText);\r\n\t\t\t\t\t\t\terr.status = jqXHR.status;\r\n\t\t\t\t\t\t\terr.statusText = statusText;\r\n\t\t\t\t\t\t\terr.request = jqXHR;\r\n\t\t\t\t\t\t\terr.method = method;\r\n\t\t\t\t\t\t\terr.url = url;\r\n\t\t\t\t\t\t\terr.data = data;\r\n\t\t\t\t\t\t\treject(err);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfunction retry(jqXHR, method, url, data, errorHandler, resolve, reject) {\r\n\t\t\t\t\tretries--;\r\n\t\t\t\t\tvar after = 3000; // 5 minutes\r\n\t\t\t\t\tvar retryAfter = jqXHR.getResponseHeader('Retry-After');\r\n\t\t\t\t\tif (retryAfter) {\r\n\t\t\t\t\t\tvar tmp = parseInt(retryAfter, 10);\r\n\t\t\t\t\t\tif (! isNaN(tmp)) {\r\n\t\t\t\t\t\t\tafter = tmp * 1000; // seconds to ms.\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tsetTimeout(function(){\r\n\t\t\t\t\t\trequest(method, url, data, errorhandler, resolve, reject);\r\n\t\t\t\t\t}, after);\r\n\t\t\t\t}\r\n\t\t\t})(method, url, data, this.cfg.timeout, this.cfg.retryCount, this.cfg.retryWaitTime);\r\n\t\t}\r\n\t});\r\n\r\n\tfunction RestDataStoreFactory(name, url, cfg) {\r\n\t\treturn new RestDataStore(name, url, cfg);\r\n\t}\r\n\t\r\n\tDataStore.registerType('http', RestDataStoreFactory);\r\n\tDataStore.registerType('https', RestDataStoreFactory);\r\n\r\n\treturn RestDataStore;\r\n});\r\n\n","define('bridalapp/named',['bridalapp/class', 'bridalapp/persistent'], function (Class, Persistent) {\r\n\tvar Named = Class('Named', Persistent, {\r\n\t\tinitialize: function Named_initialize($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.name = (obj && obj.name) || null;\r\n\t\t},\r\n\t\t\r\n\t\ttoString: function Named_toString() {\r\n\t\t\treturn '[Object ' + this.type + ' \\'' + this.name + '\\' ' + this.id.toString() + ' v' + this.version + ']';\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn Named;\r\n});\r\n\n","define('bridalapp/account',['bridalapp/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Account = Class('Account', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.roles = (obj && obj.roles) || [];\r\n\t\t\tthis.groups = (obj && obj.groups) || [];\r\n\t\t\tthis.credentials = (obj && obj.credentials) || [];\r\n\t\t}\r\n\t});\r\n\r\n\treturn Account;\r\n});\n","define('bridalapp/brand',['bridalapp/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Brand = Class('Brand', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t}\r\n\t});\r\n\r\n\treturn Brand;\r\n});\n","define('bridalapp/synchrequest',['bridalapp/class'], function(Class){\r\n\tvar SynchRequest = Class('SynchRequest', {\r\n\t\tinitialize: function(obj) {\r\n\t\t\tthis.unsynchedDuration = (obj && obj.synchDuration) || 0;\r\n\t\t\tthis.criteria = (obj && obj.criteria) || null;\r\n\t\t\tthis.currentIds = (obj && obj.currentIds) || [];\r\n\t\t\tthis.currentVersions = (obj && obj.currentVersions) || [];\r\n\t\t\tthis.createdItems = (obj && obj.createdItems) || [];\r\n\t\t\tthis.updatedItems = (obj && obj.updatedItems) || [];\r\n\t\t\tthis.deletedItems = (obj && obj.deletedItems) || [];\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn SynchRequest;\r\n});\n","define('bridalapp/synchresponse',['bridalapp/class'], function(Class){\r\n\tvar SynchResponse = Class('SynchResponse', {\r\n\t\tinitialize: function(obj) {\r\n\t\t\tthis.createdItems = (obj && obj.createdItems) || [];\r\n\t\t\tthis.updatedItems = (obj && obj.updatedItems) || [];\r\n\t\t\tthis.staleItems = (obj && obj.staleItems) || [];\r\n\t\t\tthis.failedItems = (obj && obj.failedItems) || [];\r\n\t\t\tthis.deletedIds = (obj && obj.deletedIds) || [];\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn SynchResponse;\r\n});\n","define('bridalapp/syncheddatastore',['bridalapp/class', \r\n\t\t'jquery', \r\n\t\t'bridalapp/log', \r\n\t\t'bridalapp/persistent', \r\n\t\t'bridalapp/datastore', \r\n\t\t'bridalapp/synchabledatastore', \r\n\t\t'bridalapp/synchrequest', \r\n\t\t'bridalapp/synchresponse'], \r\n\r\nfunction (Class, $, log, Persistent, DataStore, SynchableDataStore, SynchRequest, SynchResponse) {\r\n\t'use strict';\r\n\r\n\tvar SynchedDataStore = Class('SynchedDataStore', SynchableDataStore, {\r\n\t\t\r\n\t\tinitialize: function SynchedDataStore_initialize($super, name, url, cfg) {\r\n\t\t\t$super(name, url, cfg);\r\n\t\t\tthis.synching = false;\r\n\t\t\tthis.synchError = false;\r\n\t\t\tcfg = this.cfg;\r\n\t\t\tif (cfg.autoSynch === undefined) {cfg.autoSynch = true;}\r\n\t\t\tif (!cfg.synchInterval) {cfg.synchInterval = 30 * 1000;}    // 30 sec.\r\n\t\t\tif (!cfg.pollInterval) {cfg.pollInterval = 30 * 60 * 1000;} // 30 min.\r\n\t\t\tif (cfg.remoteSynch === undefined) {cfg.remoteSynch = true;}\r\n\t\t\tif ((! cfg.localDataStore) || (! cfg.remoteDataStore)) {\r\n\t\t\t\t// url: 'synched://rhaboo/bridal-app/ratings#http/api/ratings'\r\n\t\t\t\tvar urls = url.split('://')[1].split('#');\r\n\t\t\t\tif (! cfg.localDataStore) {\r\n\t\t\t\t\tvar localParts=urls[0].split('/'), \r\n\t\t\t\t\t\tlocalType=localParts[0],\r\n\t\t\t\t\t\tlocalRepo=localParts.slice(1, localParts.length-1).join('/'),\r\n\t\t\t\t\t\tlocalStore=localParts[localParts.length-1];\r\n\t\t\t\t\tcfg.localDataStore = DataStore.fromType(name, localType, \r\n\t\t\t\t\t\t\tlocalType + '://' + localRepo + '/' + localStore);\r\n\t\t\t\t\tif (! (cfg.localDataStore instanceof SynchableDataStore)) {\r\n\t\t\t\t\t\tif (cfg.localDataStore) {\r\n\t\t\t\t\t\t\tlog().error('Unable to initialize SynchedDataStore \\'' + name + '\\'.' + \r\n\t\t\t\t\t\t\t\t\t'Need a synchable datastore for the local side, ' + \r\n\t\t\t\t\t\t\t\t\t'but ' + cfg.localDataStore + ' is not a SynchableDataStore.');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tlog().error('Unable to initialize SynchedDataStore \\'' + name + '\\'.' + \r\n\t\t\t\t\t\t\t\t\t'Need a synchable datastore for the local side, but ' + \r\n\t\t\t\t\t\t\t\t\t'could not find a datastore for url \\'' + urls[0] + '\\'.');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (! cfg.remoteDataStore) {\r\n\t\t\t\t\tvar remoteParts=urls[1].split('/'),\r\n\t\t\t\t\t\tremoteType=remoteParts[0],\r\n\t\t\t\t\t\tremoteRepo=remoteParts.slice(1, remoteParts.length-1).join('/'),\r\n\t\t\t\t\t\tremoteStore=remoteParts[remoteParts.length-1];\r\n\t\t\t\t\tcfg.remoteDataStore = DataStore.fromType(name, remoteType, '/' + remoteRepo + '/' + remoteStore);\r\n\t\t\t\t\tif (! cfg.remoteDataStore) {\r\n\t\t\t\t\t\tlog().error('Unable to initialize SynchedDataStore \\'' + name + '\\'.' + \r\n\t\t\t\t\t\t\t\t'Need a datastore for the remote side, but ' + \r\n\t\t\t\t\t\t\t\t'could not find a datastore for url \\'' + urls[1] + '\\'.');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/** \r\n\t\t * Brings this datastore back into synch.\r\n\t\t * \r\n\t\t * <p>Returns a promise that resolves on synch complete or rejects on\r\n\t\t * synch failure. The arrays returned by <code>staleItems</code> and \r\n\t\t * <code>failedItems</code> will be updated with items that could not\r\n\t\t * be saved because they had been changed on the remote server in the\r\n\t\t * meantime, or that gave (integrity constraint) validation errors,\r\n\t\t * respectively.</p> \r\n\t\t */\r\n\t\tsynch: function SynchedDataStore_synch($super, force) {\r\n\t\t\tif (this.cfg.autoSynch) {autoSynch(this);}\r\n\t\t\tvar me = this, cfg = me.cfg;\r\n\t\t\tif ((!force) && me.synching) {return me.synching;}\r\n\t\t\tme.synchError = false;\r\n\t\t\tif (! cfg.remoteDataStore.cfg.supportsSynch) {return poorMansSynch(me);}\r\n\t\t\treturn me.synching = new Promise(function(resolve, reject) {\r\n\t\t\t\t// if not forced synch and store looks synched and poll interval not expired, do nothing.\r\n\t\t\t\tif ((!force) && me.looksSynched() && (Date.now() < me.lastSynched().getTime() + cfg.pollInterval)) {\r\n\t\t\t\t\t// postpone resolving until after synch method has returned.\r\n\t\t\t\t\treturn setTimeout(function(){\r\n\t\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t},0);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// synching is needed\r\n\t\t\t\tme.trigger('synch:started');\r\n\t\t\t\tvar changed = false;\r\n\t\t\t\tvar req = new SynchRequest();\r\n\t\t\t\treq.criteria = cfg.filter || null;\r\n\t\t\t\treq.createdItems.push.apply(req.createdItems, me.createdItems());\r\n\t\t\t\treq.updatedItems.push.apply(req.updatedItems, me.updatedItems());\r\n\t\t\t\treq.deletedItems.push.apply(req.deletedItems, me.deletedItems());\r\n\t\t\t\treq.currentIds.push.apply(req.currentIds, Persistent.pluck(me.items(), 'id'));\r\n\t\t\t\treq.currentVersions.push.apply(req.currentVersions, Persistent.pluck(me.items(), 'version'));\r\n\r\n\t\t\t\tcfg.remoteDataStore.synch(req).then(function(response) {\r\n\t\t\t\t\tvar i,id,idx,item;\r\n\r\n\t\t\t\t\t// handle deleted items\r\n\t\t\t\t\tif (response.deletedIds.length) {\r\n\t\t\t\t\t\tfor (i=0; id=response.deletedIds[i]; i++) {\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.items(), id);\r\n\t\t\t\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t\t\t\tme.items().splice(idx, 1);\r\n\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.deletedItems(), id);\r\n\t\t\t\t\t\t\tif (idx !== -1) {me.deletedItems().splice(idx, 1);}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.deletedIds.length + ' deleted items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// handle updated items\r\n\t\t\t\t\tif (response.updatedItems.length) {\r\n\t\t\t\t\t\tfor (i=0; item=response.updatedItems[i]; i++) {\r\n\t\t\t\t\t\t\t// if we have futureItems, try to merge the changes into the new version of the item\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.futureItems(), item)\r\n\t\t\t\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t\t\t\t// get future item and remove from list\r\n\t\t\t\t\t\t\t\tvar future = me.futureItems().splice(idx, 1)[0];\r\n\t\t\t\t\t\t\t\t// replace updated item with version from server\r\n\t\t\t\t\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\t\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1, item);}\r\n\t\t\t\t\t\t\t\telse {me.updatedItems().push(item);}\r\n\t\t\t\t\t\t\t\t// now merge changes from future item onto server item\r\n\t\t\t\t\t\t\t\tvar merged = Persistent.clone(item);\r\n\t\t\t\t\t\t\t\tfor (var key in future) {\r\n\t\t\t\t\t\t\t\t\tif (key !== 'version') {\r\n\t\t\t\t\t\t\t\t\t\tmerged[key] = future[key]; \r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// replace item with the merged version\r\n\t\t\t\t\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\t\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t\t\t\t\tme.items().splice(idx, 1, merged);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t// remove saved item from the updatedItems list\r\n\t\t\t\t\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\t\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1);}\r\n\t\t\t\t\t\t\t\telse {changed = true;}\r\n\t\t\t\t\t\t\t\t// replace item with the saved version\r\n\t\t\t\t\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\t\t\t\t\tif (idx !== -1) {me.items().splice(idx, 1, item);}\r\n\t\t\t\t\t\t\t\telse {me.items().push(item);}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.updatedItems.length + ' updated items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// handle created items\r\n\t\t\t\t\tif (response.createdItems.length) {\r\n\t\t\t\t\t\tfor (i=0; item=response.createdItems[i]; i++) {\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\t\t\t\tif (idx === -1) {\r\n\t\t\t\t\t\t\t\tme.items().push(item);\r\n\t\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {me.items().splice(idx, 1, item);}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.createdItems.length + ' created items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// handle stale items\r\n\t\t\t\t\tif (response.staleItems.length) {\r\n\t\t\t\t\t\tfor (i=0; item=response.staleItems[i]; i++) {\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.staleItems(), item);\r\n\t\t\t\t\t\t\tif (idx === -1) {me.staleItems().push(item);}\r\n\t\t\t\t\t\t\telse {me.staleItems().splice(idx, 1, item);}\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.createdItems(), item);\r\n\t\t\t\t\t\t\tif (idx !== -1) {me.createdItems().splice(idx, 1);}\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1);}\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.deletedItems(), item);\r\n\t\t\t\t\t\t\tif (idx !== -1) {me.deletedItems().splice(idx, 1);}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.staleItems.length + ' stale items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (response.failedItems.length) {\r\n\t\t\t\t\t\t// handle failed items\r\n\t\t\t\t\t\tfor (i=0; item=response.failedItems[i]; i++) {\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.failedItems(), item);\r\n\t\t\t\t\t\t\tif (idx === -1) {me.failedItems().push(item);}\r\n\t\t\t\t\t\t\telse {me.failedItems().splice(idx, 1, item);}\r\n\t\t\t\t\t\t\tif (Persistent.indexOf(me.createdItems(), item) !== -1) {\r\n\t\t\t\t\t\t\t\t// created items is a virtual array, remove from items\r\n\t\t\t\t\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\t\t\t\t\tif (idx !== -1) {me.items().splice(idx, 1);}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1);}\r\n\t\t\t\t\t\t\tidx = Persistent.indexOf(me.deletedItems(), item);\r\n\t\t\t\t\t\t\tif (idx !== -1) {me.deletedItems().splice(idx, 1);}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlog().log('Processed ' + response.failedItems.length + ' failed items.');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tme.lastSynched(new Date());\r\n\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\tif (changed) {me.trigger('change');} \r\n\t\t\t\t\tme.trigger('synch:success');\r\n\t\t\t\t\tresolve();\r\n\t\t\t\t\tme.trigger('synch:done');\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\tme.synchError = e;\r\n\t\t\t\t\tme.trigger('synch:failed');\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t\tme.trigger('synch:done');\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/** Indicates whether this datastore is currently busy synching. */\r\n\t\tisSynching: function SynchedDataStore_isSynching() {\r\n\t\t\treturn !!this.synching;\r\n\t\t},\r\n\r\n\t\t// IMPLEMENT ALL ABSTRACT METHODS.\r\n\t\t// ASYNCH methods will call synch to try to make sure after the call the results\r\n\t\t// are consistent for both the local as well as the remote datastore.\r\n\t\tload: function SynchedDataStore_load(criteria, pageSize, pageIndex) {\r\n\t\t\tvar me = this;\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tthis.synch().then(function(){\r\n\t\t\t\t\tme.cfg.localDataStore.load(criteria, pageSize, pageIndex).then(function(items){\r\n\t\t\t\t\t\tresolve(items);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}); \r\n\t\t},\r\n\r\n\t\tcount: function SynchedDataStore_count(criteria) {\r\n\t\t\tvar me = this;\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tthis.synch().then(function(){\r\n\t\t\t\t\tme.cfg.localDataStore.count(criteria, pageSize, pageIndex).then(function(count){\r\n\t\t\t\t\t\tresolve(count);\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}); \r\n\t\t},\r\n\r\n\t\tsave: function SynchedDataStore_save(item) {\r\n\t\t\tvar me = this;\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tme.cfg.localDataStore.save(item).then(function(items){\r\n\t\t\t\t\tme.synch().then(function(){\r\n\t\t\t\t\t\tresolve(items);\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}); \r\n\t\t},\r\n\r\n\t\tdelete: function SynchedDataStore_delete(item) {\r\n\t\t\tvar me = this;\r\n\t\t\treturn new Promise(function(resolve, reject){\r\n\t\t\t\tme.cfg.localDataStore.delete(item).then(function(items){\r\n\t\t\t\t\tme.synch().then(function(){\r\n\t\t\t\t\t\tresolve(items);\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}); \r\n\t\t},\r\n\t\t\r\n\t\t// synchronous methods will interact with the local datastore only (remote does not support synchronous invocation)\r\n\t\t/** Gets or sets the (local/device) date time this datastore was last synched. */\r\n\t\tlastSynched: function SynchedDataStore_lastSynched(newDate) {\r\n\t\t\treturn this.cfg.localDataStore.lastSynched(newDate);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns an 'immutable' array that represents a live view of the items\r\n\t\t * maintained in this store. \r\n\t\t * \r\n\t\t * <p>The result of this method can be used for observing/monitoring the\r\n\t\t * data set. DO NOT MUTATE THIS ARRAY!.</p>\r\n\t\t */\r\n\t\titems: function SynchedDataStore_items() {\r\n\t\t\treturn this.cfg.localDataStore.items();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that have been added to the store since the last synch. */\r\n\t\tcreatedItems: function SynchedDataStore_createdItems() {\r\n\t\t\treturn this.cfg.localDataStore.createdItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of the original versions of items that have been updated since the last synch. */\r\n\t\tupdatedItems: function SynchedDataStore_updatedItems() {\r\n\t\t\treturn this.cfg.localDataStore.updatedItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that have been deleted since the last synch. */\r\n\t\tdeletedItems: function SynchedDataStore_deletedItems() {\r\n\t\t\treturn this.cfg.localDataStore.deletedItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that could not be saved during the last synch because they went stale. */\r\n\t\tstaleItems: function SynchedDataStore_staleItems() {\r\n\t\t\treturn this.cfg.localDataStore.staleItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** 'Immutable' array of items that could not be saved during the last synch because they had errors. */\r\n\t\tfailedItems: function SynchedDataStore_failedItems() {\r\n\t\t\treturn this.cfg.localDataStore.failedItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** \r\n\t\t * 'Immutable' array of items that were already updated when a synch started and were then updated again while synch was in progress.\r\n\t\t *  These items are effectively stale, but because the user edited his own items, we can safely assume\r\n\t\t *  he wishes to overwrite the remote version with the item that is in this list.\r\n\t\t */\r\n\t\tfutureItems: function SynchedDataStore_futureItems() {\r\n\t\t\treturn this.cfg.localDataStore.futureItems();\r\n\t\t},\r\n\t\t\r\n\t\t/** \r\n\t\t * Synchronous equivalent of <code>save</code>.\r\n\t\t * \r\n\t\t * <p>The arrays returned by <code>updatedItems</code>, <code>createdItems</code>\r\n\t\t * and <code>removedItems</code> will be updated to reflect the changes made\r\n\t\t * to the datastore since the last synch.</p>\r\n\t\t */\r\n\t\tset: function SynchedDataStore_set(item) {\r\n\t\t\treturn this.cfg.localDataStore.set(item);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Synchronous equivalent of <code>delete</code>.\r\n\t\t *  \r\n\t\t * <p>The arrays returned by <code>updatedItems</code>, <code>createdItems</code>\r\n\t\t * and <code>removedItems</code> will be updated to reflect the changes made\r\n\t\t * to the datastore since the last synch.</p>\r\n\t\t */\r\n\t\tdel: function SynchedDataStore_del(item) {\r\n\t\t\treturn this.cfg.localDataStore.del(item);\r\n\t\t}\r\n\t});\r\n\r\n\tDataStore.registerType('synched', function SynchedDataStoreFactory(name, url, cfg) {\r\n\t\treturn new SynchedDataStore(name, url, cfg);\r\n\t});\r\n\t\r\n\tfunction handleLoadedItems(me, items) {\r\n\t\tvar item, old, idx, changed=false;\r\n\t\t// all items we got from the remote should be added if we did not have them on local,\r\n\t\t// or updated locally if the version we got from the remote was different. only the \r\n\t\t// remote updates the version, so it being different means our version is older.\r\n\t\tfor (var i=0; item=items[i]; i++) {\r\n\t\t\tidx = Persistent.indexOf(me.items(), item); \r\n\t\t\tif (idx === -1) {\r\n\t\t\t\t// item is not in local. either it's new on remote, or was deleted on local\r\n\t\t\t\tidx = Persistent.indexOf(me.deletedItems(), item);\r\n\t\t\t\tif (idx !== -1) {\r\n\t\t\t\t\t// item was deleted on local. check version\r\n\t\t\t\t\tif (item.version !== me.deletedItems()[idx].version) {\r\n\t\t\t\t\t\t// item was deleted locally, but edited on server, so our deleted\r\n\t\t\t\t\t\t// version becomes stale, but as we deleted it we don't care and\r\n\t\t\t\t\t\t// don't add it to stale. We just remove it from deletedItems.\r\n\t\t\t\t\t\tme.deletedItems().splice(idx, 1);\r\n\t\t\t\t\t\t// add the new version of the item we had deleted\r\n\t\t\t\t\t\tme.items().push(item);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// item is new on remote\r\n\t\t\t\t\tme.items().push(item);\r\n\t\t\t\t}\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// item is already in local. check version\r\n\t\t\t\tif (item.version !== me.items()[idx].version) {\r\n\t\t\t\t\t// local version is older than remote version. replace\r\n\t\t\t\t\told = me.items().splice(idx, 1, item)[0]; \r\n\t\t\t\t\t// if we had updated this item, the update went stale\r\n\t\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), old); \r\n\t\t\t\t\tif (idx !== -1){\r\n\t\t\t\t\t\t// changed item was updated, so went stale\r\n\t\t\t\t\t\tme.updatedItems().splice(idx, 1);\r\n\t\t\t\t\t\tidx = Persistent.indexOf(me.staleItems(), old); \r\n\t\t\t\t\t\tif (idx === -1) {me.staleItems().push(old);}\r\n\t\t\t\t\t\telse {me.staleItems().splice(idx, 1, old);}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tchanged = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// all items we did NOT get from the remote should be removed locally, \r\n\t\t// except for newly created ones\r\n\t\tfor (var i=me.items().length-1; i>=0; i--) {\r\n\t\t\titem = me.items()[i];\r\n\t\t\tif ((Persistent.indexOf(items, item) === -1) &&\r\n\t\t\t\t(Persistent.indexOf(me.createdItems(), item) === -1)){ \r\n\t\t\t\t// item is not new, but does not exist (any more) on the remote\r\n\t\t\t\tvar old = me.items().splice(i, 1)[0];\r\n\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), old);\r\n\t\t\t\tif (idx !== -1) { \r\n\t\t\t\t\t// removed item was updated locally, so went stale\r\n\t\t\t\t\tthis.updatedItems().splice(idx, 1);\r\n\t\t\t\t\tidx = Persistent.indexOf(me.staleItems(), old); \r\n\t\t\t\t\tif (staleIdx === -1) {me.staleItems().push(old);}\r\n\t\t\t\t\telse {me.staleItems().splice(idx, 1, old);}\r\n\t\t\t\t}\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (changed) {me.trigger('change');}\r\n\t}\r\n\r\n\tfunction handleSavedItems(me, items) {\r\n\t\tfor (var i=0,item; item=items[i]; i++) {\r\n\t\t\t// if we have futureItems, try to merge the changes into the new version of the item\r\n\t\t\tvar idx = Persistent.indexOf(me.futureItems(), item)\r\n\t\t\tif (idx !== -1) {\r\n\t\t\t\tvar future = me.futureItems().splice(idx, 1)[0];\r\n\t\t\t\t// replace updatedItems with version from server\r\n\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1, item);}\r\n\t\t\t\telse {me.updatedItems().push(item);}\r\n\t\t\t\t// now merge changes from future item onto server item\r\n\t\t\t\tvar merged = Persistent.clone(item);\r\n\t\t\t\tfor (var key in future) {\r\n\t\t\t\t\tif (key !== 'version') {\r\n\t\t\t\t\t\tmerged[key] = future[key]; \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// replace items with the merged version\r\n\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\tif (idx !== -1) {me.items().splice(idx, 1, merged);}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// remove saved item from the updatedItems list\r\n\t\t\t\tidx = Persistent.indexOf(me.updatedItems(), item);\r\n\t\t\t\tif (idx !== -1) {me.updatedItems().splice(idx, 1);}\r\n\t\t\t\t// replace items with the saved version\r\n\t\t\t\tidx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\tif (idx !== -1) {me.items().splice(idx, 1, item);}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction handleDeletedItems(me, items) {\r\n\t\tfor (var i=0,item; item=items[i]; i++) {\r\n\t\t\tvar idx = Persistent.indexOf(me.deletedItems(), item);\r\n\t\t\tif (idx !== -1) {me.deletedItems().splice(idx, 1);}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction poorMansSynch(me) {\r\n\t\tvar cfg = me.cfg;\r\n\t\treturn me.synching = new Promise(function(resolve, reject) {\r\n\t\t\t// if store looks synched and poll interval not expired, do nothing.\r\n\t\t\tif (me.looksSynched() && (Date.now() < me.lastSynched().getTime() + cfg.pollInterval)) {\r\n\t\t\t\t// postpone resolving until after synch method has returned.\r\n\t\t\t\treturn setTimeout(function(){\r\n\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\tresolve();\r\n\t\t\t\t},0);\r\n\t\t\t}\r\n\t\t\t// synching is needed\r\n\t\t\tme.trigger('synch:started');\r\n\t\t\tcfg.remoteDataStore.load().then(function(items) {\r\n\t\t\t\t// handle loaded items, save dirty items and delete removed items\r\n\t\t\t\thandleLoadedItems(me, items);\r\n\t\t\t\t// now that we processed all loaded items we can save our changes.\r\n\t\t\t\t// Make a snapshot of current state: dirty and deleted items.\r\n\t\t\t\tvar dirty = me.createdItems().concat();\r\n\t\t\t\tfor (var i=0,item; item=me.updatedItems()[i]; i++) {\r\n\t\t\t\t\t// The items in updated are the old versions, so get the corresponding new version\r\n\t\t\t\t\tvar idx = Persistent.indexOf(me.items(), item);\r\n\t\t\t\t\tif (idx !== -1) {dirty.push(me.items()[idx]);}\r\n\t\t\t\t}\r\n\t\t\t\tvar deleted = me.deletedItems().concat();\r\n\t\t\t\t// delete items first\r\n\t\t\t\tnew Promise(function(resolve, reject){\r\n\t\t\t\t\tif (! deleted.length) {resolve(); return;}\r\n\t\t\t\t\tcfg.remoteDataStore.delete(deleted).then(function(items){\r\n\t\t\t\t\t\thandleDeletedItems(me, items);\r\n\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).then(function(){\r\n\t\t\t\t\t// items are deleted, now we can create new, or update\r\n\t\t\t\t\tnew Promise(function(resolve, reject){\r\n\t\t\t\t\t\tif (! dirty.length) {resolve(); return;}\r\n\t\t\t\t\t\tcfg.remoteDataStore.save(dirty).then(function(items){\r\n\t\t\t\t\t\t\thandleSavedItems(me, items);\r\n\t\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}).then(function(){\r\n\t\t\t\t\t\tme.lastSynched(new Date());\r\n\t\t\t\t\t\tme.synching = false;\r\n\t\t\t\t\t\tme.synchError = false;\r\n\t\t\t\t\t\tme.trigger('synch:success');\r\n\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t\tme.trigger('synch:done');\r\n\t\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(function(e){\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t});\r\n\t\t\t}).catch(function(e) {\r\n\t\t\t\t// load failed\r\n\t\t\t\tme.synching = false;\r\n\t\t\t\tme.synchError = e;\r\n\t\t\t\tme.trigger('synch:failed');\r\n\t\t\t\treject(e);\r\n\t\t\t\tme.trigger('synch:done');\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\tfunction autoSynch(me) {\r\n\t\tif (! me.autoSynchActive) {\r\n\t\t\tme.autoSynchActive = true;\r\n\t\t\tsetInterval(function(){\r\n\t\t\t\tme.synch();\r\n\t\t\t}, me.cfg.synchInterval);\r\n\t\t}\r\n\t}\r\n\r\n\treturn SynchedDataStore;\r\n});\r\n\n","define('bridalapp/brands',['bridalapp/class', \r\n\t\t'bridalapp/syncheddatastore',\r\n\t\t'bridalapp/rhaboodatastore', \r\n\t\t'bridalapp/restdatastore',\r\n],\r\nfunction (Class, SynchedDataStore) {\r\n\tvar Brands = Class('Brands', SynchedDataStore, {\r\n\t\tinitialize: function Brands_initialize($super) {\r\n\t\t\t$super('brands', 'synched://rhaboo/bridal-app/brands#http/api/brands');\r\n\t\t}\r\n\t});\r\n\r\n\treturn new Brands();\r\n});\r\n\n","define('bridalapp/category',['bridalapp/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Category = Class('Category', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t}\r\n\t});\r\n\r\n\treturn Category;\r\n});\n","define('bridalapp/credential',['bridalapp/class', 'bridalapp/persistent'], function(Class, Persistent){\r\n\tvar Credential = Class('Credential', Persistent, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn Credential;\r\n});\n","define('bridalapp/group',['bridalapp/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Group = Class('Group', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.description = (obj && obj.description) || null;\r\n\t\t}\r\n\t});\r\n\r\n\treturn Group;\r\n});\n","define('bridalapp/password-credential',['bridalapp/class', 'bridalapp/credential'], function(Class, Credential){\r\n\tvar PasswordCredential = Class('PasswordCredential', Credential, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.password = (obj && obj.password) || null;\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn PasswordCredential;\r\n});\n","define('bridalapp/product',['bridalapp/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Product = Class('Product', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.description = (obj && obj.description) || null;\r\n\t\t\tthis.priceWholesaleEuroCent = (obj && obj.priceWholesaleEuroCent) || null;\r\n\t\t\tthis.priceConsumerEuroCent = (obj && obj.priceConsumerEuroCent) || null;\r\n\t\t\tthis.brandId = (obj && obj.brandId) || null;\r\n\t\t\tthis.brandName = (obj && obj.brandName) || null;\r\n\t\t\tthis.categoryId = (obj && obj.categoryId) || null;\r\n\t\t\tthis.categoryName = (obj && obj.categoryName) || null;\r\n\t\t\tthis.tags = (obj && obj.tags) || null;\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn Product;\r\n});\n","define('bridalapp/products',['bridalapp/class', \r\n\t\t'bridalapp/syncheddatastore', \r\n\t\t'bridalapp/rhaboodatastore', \r\n\t\t'bridalapp/restdatastore',\r\n], \r\nfunction (Class, SynchedDataStore) {\r\n\tvar Products = Class('Products', SynchedDataStore, {\r\n\t\tinitialize: function Products_initialize($super) {\r\n\t\t\t$super('products', 'synched://rhaboo/bridal-app/products#http/api/products');\r\n\t\t\tthis.cfg.remoteDataStore.cfg.supportsSynch = true;\r\n\t\t}\r\n\t});\r\n\r\n\treturn new Products();\r\n});\r\n\n","define('bridalapp/rating',['bridalapp/class', 'bridalapp/persistent'], function(Class, Persistent){\r\n\tvar Rating = Class('Rating', Persistent, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t\tthis.productId = (obj && obj.productId) || null;\r\n\t\t\tthis.accountId = (obj && obj.accountId) || null;\r\n\t\t\tthis.score = (obj && obj.score) || null;\r\n\t\t}\r\n\t});\r\n\r\n\treturn Rating;\r\n});\n","define('bridalapp/ratings',['bridalapp/class', \r\n\t\t'bridalapp/syncheddatastore',\r\n\t\t'bridalapp/rhaboodatastore',\r\n\t\t'bridalapp/restdatastore',\r\n], \r\nfunction (Class, SynchedDataStore) {\r\n\tvar Ratings = Class('Ratings', SynchedDataStore, {\r\n\t\tinitialize: function Ratings_initialize($super) {\r\n\t\t\t$super('ratings', 'synched://rhaboo/bridal-app/ratings#http/api/ratings');\r\n\t\t\tthis.cfg.remoteDataStore.cfg.supportsSynch = true;\r\n\t\t}\r\n\t});\r\n\r\n\treturn new Ratings();\r\n});\r\n\n","define('bridalapp/role',['bridalapp/class', 'bridalapp/named'], function(Class, Named){\r\n\tvar Role = Class('Role', Named, {\r\n\t\tinitialize: function($super, obj) {\r\n\t\t\t$super(obj);\r\n\t\t}\r\n\t});\r\n\r\n\treturn Role;\r\n});\n","/**!\r\n * @copyright (c) 2015 by Stijn de Witt. Some rights reserved.\r\n * @license <a href=\"https://creativecommons.org/licenses/by/4.0/\">Attribution 4.0 International (CC BY 4.0)</a> \r\n */\r\ndefine('bridalapp',[\r\n\t\t'bridalapp/rhaboodatastore',\r\n\t\t'bridalapp/restdatastore',\r\n\t\t// Pull in all classes\r\n\t\t'bridalapp/account', \r\n\t\t'bridalapp/brand',\r\n\t\t'bridalapp/brands',\r\n\t\t'bridalapp/category',\r\n\t\t'bridalapp/credential',\r\n\t\t'bridalapp/group',\r\n\t\t'bridalapp/log', \r\n\t\t'bridalapp/named',\r\n\t\t'bridalapp/password-credential', \r\n\t\t'bridalapp/persistent',\r\n\t\t'bridalapp/product',\r\n\t\t'bridalapp/products',\r\n\t\t'bridalapp/rating',\r\n\t\t'bridalapp/ratings',\r\n\t\t'bridalapp/role'\r\n\t], \r\n\t\r\nfunction(\r\n\tRhabooDataStore,\r\n\tRestDataStore,\r\n\tAccount, \r\n\tBrand,\r\n\tBrands,\r\n\tCategory,\r\n\tCredential,\r\n\tGroup,\r\n\tlog,\r\n\tNamed,\r\n\tPasswordCredential, \r\n\tPersistent,\r\n\tProduct,\r\n\tProducts,\r\n\tRating,\r\n\tRatings,\r\n\tRole\r\n){\r\n\t// Create a namespace with all classes in it and return it\r\n\treturn {\r\n\t\tAccount: Account, \r\n\t\tBrand: Brand,\r\n\t\tBrands: Brands,\r\n\t\tCategory: Category,\r\n\t\tCredential: Credential,\r\n\t\tGroup: Group,\r\n\t\tlog: log,\r\n\t\tNamed: Named,\r\n\t\tPasswordCredential: PasswordCredential, \r\n\t\tPersistent: Persistent,\r\n\t\tProduct: Product,\r\n\t\tProducts: Products,\r\n\t\tRating: Rating,\r\n\t\tRatings: Ratings,\r\n\t\tRole: Role,\r\n\t\t\r\n\t\tglobalize: function(global){\r\n\t\t\tfor (var key in this) {\r\n\t\t\t\tif (this.hasOwnProperty(key)) {\r\n\t\t\t\t\tglobal[key] = this[key];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n);\n"]}